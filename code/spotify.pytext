# -*- coding: utf-8 -*-
#
# Copyright (c) 2017-2018 Spotify AB
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Module for logic related to chart axes.
"""

import pandas as pd
import bokeh
from bokeh.models.tickers import FixedTicker
from math import pi


class BaseAxes:
    """Base class for axes."""

    def __init__(self, chart):
        self._chart = chart
        self._initialize_defaults()

    @classmethod
    def _get_axis_class(cls, x_axis_type, y_axis_type):
        if x_axis_type == 'categorical' and y_axis_type == 'categorical':
            return CategoricalXYAxes
        elif x_axis_type == 'categorical':
            return NumericalYAxis
        elif y_axis_type == 'categorical':
            return NumericalXAxis
        elif x_axis_type == 'datetime':
            return DatetimeXNumericalYAxes
        return NumericalXYAxes

    @property
    def _vertical(self):
        if self._chart._x_axis_type == 'density':
            return False
        elif isinstance(self, (NumericalYAxis,
                               NumericalXYAxes,
                               DatetimeXNumericalYAxes)):
            return True
        else:
            return False

    def _initialize_defaults(self):
        xaxis_label = """ch.axes.set_xaxis_label('label (units)')"""
        yaxis_label = """ch.axes.set_yaxis_label('label (units)')"""
        if self._chart._blank_labels:
            xaxis_label = ''
            yaxis_label = ''
        self.set_xaxis_label(xaxis_label)
        self.set_yaxis_label(yaxis_label)

    @staticmethod
    def _convert_major_orientation_labels(orientation):
        """Map the user inputted orientation values to the values expected by
        bokeh for major labels."""
        if orientation == 'vertical':
            orientation = pi / 180 * 90
        elif orientation == 'diagonal':
            orientation = pi / 180 * 45
        elif orientation != 'horizontal':
            raise ValueError(
                'Orientation must be `horizontal`, `vertical`, or `diagonal`.')
        return orientation

    def _convert_subgroup_orientation_labels(self, orientation):
        """Map the user inputted orientation values to the values expected by
        bokeh for group labels."""

        if self._vertical:
            horizontal_value = 'parallel'
            vertical_value = pi / 180 * 90
        else:
            horizontal_value = 'normal'
            vertical_value = 'parallel'

        if orientation == 'horizontal':
            orientation = horizontal_value
        elif orientation == 'vertical':
            orientation = vertical_value
        elif orientation == 'diagonal':
            orientation = pi / 180 * 45
        else:
            raise ValueError(
                'Orientation must be `horizontal`, `vertical`, or `diagonal`.')
        return orientation

    @property
    def xaxis_label(self):
        """Return x-axis label.
        Returns:
            x-axis label text
        """
        return self._chart.figure.xaxis[0].axis_label

    def set_xaxis_label(self, label):
        """Set x-axis label text.
        Args:
            label (string): the text for the x-axis label
        Returns:
            Current chart object
        """
        self._chart.figure.xaxis.axis_label = label
        return self._chart

    @property
    def yaxis_label(self):
        """Return y-axis label.
        Returns:
            y-axis label text
        """
        return self._chart.figure.yaxis.axis_label

    def set_yaxis_label(self, label):
        """Set y-axis label text.
        Args:
            label (string): the text for the y-axis label
        Returns:
            Current chart object
        """
        self._chart.figure.yaxis.axis_label = label
        return self._chart

    def hide_xaxis(self):
        """Hide the tick labels, ticks, and axis lines of the x-axis.
        The x-axis label will remain visible, but can be
        removed with .axes.set_xaxis_label("")
        """
        # self._chart.figure.xaxis.visible = False

        self._chart.figure.xaxis.axis_line_alpha = 0
        self._chart.figure.xaxis.major_tick_line_color = None
        self._chart.figure.xaxis.minor_tick_line_color = None
        self._chart.figure.xaxis.major_label_text_color = None

        return self._chart

    def hide_yaxis(self):
        """Hide the tick labels, ticks, and axis lines of the y-axis.
        The y-axis label will remain visible, but can be
        removed with .axes.set_yaxis_label("")
        """
        self._chart.figure.yaxis.axis_line_alpha = 0
        self._chart.figure.yaxis.major_tick_line_color = None
        self._chart.figure.yaxis.minor_tick_line_color = None
        self._chart.figure.yaxis.major_label_text_color = None

        return self._chart

    def set_xaxis_tick_orientation(self, orientation='horizontal'):
        """Change the orientation or the x axis tick labels.
        Args:
            orientation (str or list of str):
                str: 'horizontal', 'vertical', or 'diagonal'
                list of str: different orientation values corresponding to each
                level of the grouping. Example: ['horizontal', 'vertical']
        """

        if not isinstance(orientation, list):
            orientation = [orientation] * 3

        level_1 = orientation[0]
        level_2 = orientation[1] if len(orientation) > 1 else 'horizontal'
        level_3 = orientation[2] if len(orientation) > 2 else level_2

        level_1 = self._convert_major_orientation_labels(level_1)
        level_2 = self._convert_subgroup_orientation_labels(level_2)
        level_3 = self._convert_subgroup_orientation_labels(level_3)

        self._chart.figure.xaxis.major_label_orientation = level_1
        self._chart.figure.xaxis.subgroup_label_orientation = level_2
        self._chart.figure.xaxis.group_label_orientation = level_3
        return self._chart


class NumericalXMixin:
    def set_xaxis_range(self, start=None, end=None):
        """Set x-axis range.
        Args:
            start (numeric, optional): the start of the x-axis range
            end (numeric, optional): the end of the x-axis range
        Returns:
            Current chart object
        """
        self._chart.figure.x_range.end = end
        self._chart.figure.x_range.start = start
        return self._chart

    def set_xaxis_tick_values(self, values):
        """Set x-axis tick values.
        Args:
            values (list or DatetimeIndex): Values for the axis ticks.
        Returns:
            Current chart object
        """
        self._chart.figure.xaxis.ticker = FixedTicker(ticks=values)
        return self._chart

    def set_xaxis_tick_format(self, num_format):
        """Set x-axis tick label number format.
        Args:
            num_format (string): the number format for the x-axis tick labels
        Examples:
            Decimal precision
            >>> ch.set_xaxis_tick_format('0.0')
            Label format: 1000 -> 1000.0
            Percentage
            >>> ch.set_xaxis_tick_format("0%")
            Label format: 0.9748 -> 97%
            0.974878234 ‘0.000%’    97.488%
            Currency:
            >>> ch.set_xaxis_tick_format('$0,0.00')
            Label format: 1000.234 -> $1,000.23
            Auto formatting:
            >>> ch.set_xaxis_tick_format('0 a')
            Label format: 10000 -> 10 K
            Additional documentation: http://numbrojs.com/old-format.html
        Returns:
            Current chart object
        """
        self._chart.figure.xaxis[0].formatter = (
            bokeh.models.NumeralTickFormatter(format=num_format)
            )
        return self._chart


class NumericalYMixin:
    def set_yaxis_range(self, start=None, end=None):
        """Set y-axis range.
        Args:
            start (numeric, optional): the start of the y-axis range
            end (numeric, optional): the end of the y-axis range
        Returns:
            Current chart object
        """
        self._chart.figure.y_range.end = end
        self._chart.figure.y_range.start = start
        return self._chart

    def set_yaxis_tick_values(self, values):
        """Set y-axis tick values.
        Args:
            values (list): Values for the axis ticks.
        Returns:
            Current chart object
        """
        self._chart.figure.yaxis.ticker = FixedTicker(ticks=values)
        return self._chart

    def set_yaxis_tick_format(self, num_format):
        """Set y-axis tick label number format.
        Args:
            num_format (string): the number format for the y-axis tick labels
        Examples:
            Decimal precision
            >>> ch.set_yaxis_tick_format('0.0')
            Label format: 1000 -> 1000.0
            Percentage
            >>> ch.set_yaxis_tick_format("0%")
            Label format: 0.9748 -> 97%
            0.974878234 ‘0.000%’    97.488%
            Currency:
            >>> ch.set_yaxis_tick_format('$0,0.00')
            Label format: 1000.234 -> $1,000.23
            Auto formatting:
            >>> ch.set_xaxis_tick_format('0a')
            Label format: 10000 -> 10 K
            Additional documentation: http://numbrojs.com/old-format.html
        Returns:
            Current chart object
        """
        self._chart.figure.yaxis[
            0].formatter = bokeh.models.NumeralTickFormatter(format=num_format)
        return self._chart


class CategoricalXMixin:
    @property
    def xaxis_factors(self):
        """Return the categorical factors of the x axis.
        Can be a list or Pandas Index or MultiIndex.
        See additional usage notes in .set_xaxis_factors docstring."""
        return self._chart.figure.x_range.factors

    def set_xaxis_factors(self, factors):
        """Set the categorical factors of the x axis.
        Note:
            Advanced feature for custom sorting of factors:
            - Retrieve the factor values with .xaxis_factors
            - Reorder as necessary
            - Set the custom order with .set_xaxis_factors()
            Easier and recommended approach to reordering factors is to set the
            `categorical_order_by` and `categorical_order_ascending` parameters
            of the plotting function.
        Args:
            factors: Sequence of factors.
            Can be a list or Pandas Index or MultiIndex.
        """
        self._chart.figure.x_range.factors = factors
        return self._chart

    def hide_xaxis(self):
        super(NumericalYAxis, self).hide_xaxis()
        try:
            self._chart.figure.xaxis.subgroup_text_color = None
            self._chart.figure.xaxis.group_text_color = None
        except:
            pass
        return self._chart

    hide_xaxis.__doc__ = BaseAxes.hide_xaxis.__doc__


class CategoricalYMixin:
    @property
    def yaxis_factors(self):
        """Return the categorical factors of the y axis.
        Can be a list or Pandas Index or MultiIndex.
        See additional usage notes in .set_yaxis_factors docstring."""
        return self._chart.figure.y_range.factors

    def set_yaxis_factors(self, factors):
        """Set the categorical factors of the y axis.
        Note:
            Advanced feature for custom sorting of factors:
            - Retrieve the factor values with .yaxis_factors
            - Reorder as necessary
            - Set the custom order with .set_yaxis_factors()
            Easier and recommended approach to reordering factors is to set the
            `categorical_order_by` and `categorical_order_ascending` parameters
            of the plotting function.
        Args:
            factors: Sequence of factors.
            Can be a list or Pandas Index or MultiIndex.
        """
        self._chart.figure.y_range.factors = factors
        return self._chart

    def hide_yaxis(self):
        super(NumericalXAxis, self).hide_yaxis()
        try:
            self._chart.figure.yaxis.subgroup_text_color = None
            self._chart.figure.yaxis.group_text_color = None
        except:
            pass
        return self._chart

    def set_yaxis_tick_orientation(self, orientation='horizontal'):
        """Change the orientation or the y axis tick labels.
        Args:
            orientation (str or list of str):
                str: 'horizontal', 'vertical', or 'diagonal'
                list of str: different orientation values corresponding to each
                level of the grouping. Example: ['horizontal', 'vertical']
        """

        if not isinstance(orientation, list):
            orientation = [orientation] * 3

        level_1 = orientation[0]
        level_2 = orientation[1] if len(orientation) > 1 else 'horizontal'
        level_3 = orientation[2] if len(orientation) > 2 else level_2

        level_1 = self._convert_major_orientation_labels(level_1)
        level_2 = self._convert_subgroup_orientation_labels(level_2)
        level_3 = self._convert_subgroup_orientation_labels(level_3)

        self._chart.figure.yaxis.major_label_orientation = level_1
        self._chart.figure.yaxis.subgroup_label_orientation = level_2
        self._chart.figure.yaxis.group_label_orientation = level_3
        return self._chart

    hide_yaxis.__doc__ = BaseAxes.hide_yaxis.__doc__


class DatetimeXMixin:
    @staticmethod
    def _convert_timestamp_list_to_epoch_ms(ts_list):
        return list(
            map(
                lambda x: (
                    (pd.to_datetime(x) - pd.Timestamp("1970-01-01"))
                    // pd.Timedelta('1ms')),
                ts_list))

    @staticmethod
    def _convert_timestamp_to_epoch_ms(timestamp):
        return (pd.to_datetime(timestamp) -
                pd.Timestamp("1970-01-01")) // pd.Timedelta('1ms')

    def set_xaxis_range(self, start=None, end=None):
        """Set x-axis range.
        Args:
            start (str, pd.Timestamp, optional): the start of the x-axis range.
            end (str, pd.Timestamp, optional): the end of the x-axis range.
        Returns:
            Current chart object
        """
        if start:
            start = self._convert_timestamp_to_epoch_ms(start)
        if end:
            end = self._convert_timestamp_to_epoch_ms(end)
        self._chart.figure.x_range.end = end
        self._chart.figure.x_range.start = start
        return self._chart

    def set_xaxis_tick_values(self, values):
        """Set x-axis tick values.
        Args:
            values (list or DatetimeIndex): Values for the axis ticks.
        Note:
            Values should be a DatetimeIndex or list of
            pandas._libs.tslib.Timestamp objects.
            We suggest using pd.date_range to generate this list.
            e.g. for a range of month start dates in 2018:
            pd.date_range('2018-01-01', '2019-01-01', freq='MS')
        Returns:
            Current chart object
        """
        values = self._convert_timestamp_list_to_epoch_ms(values)
        self._chart.figure.xaxis.ticker = FixedTicker(ticks=values)
        return self._chart

    def set_xaxis_tick_format(self, date_format):
        """Set x-axis tick label date format.
        Args:
            date_format (string): the date format
            for the x-axis tick labels.
        Examples:
            Daily precision
            >>> ch.set_xaxis_tick_format('%Y-%m-%d')
            Label format: YYYY-MM-DD
            Monthly precision
            >>> ch.set_xaxis_tick_format("%Y-%m")
            Label format: YYYY-MM
            Yearly precision
            >>> ch.set_xaxis_tick_format("%Y")
            Label format: YYYY
            Second Precision
            >>> ch.set_xaxis_tick_format("%Y-%m-%d %H:%M:%S")
            Label format: YYYY-MM-DD HH:MM:SS
            Day of week and day of month
            >>> ch.set_xaxis_tick_format("%a%d")
            Label format: Wed07
            Month and year
            >>> ch.set_xaxis_tick_format("%b%y")
            Label format: Jan17
        See bokeh.models.DatetimeTickFormatter documentation
        for more formatting options.
        Returns:
            Current chart object
        """
        self._chart.figure.xaxis[
            0].formatter = bokeh.models.DatetimeTickFormatter(
                milliseconds=[date_format],
                seconds=[date_format],
                minsec=[date_format],
                minutes=[date_format],
                hourmin=[date_format],
                hours=[date_format],
                days=[date_format],
                months=[date_format],
                years=[date_format])
        return self._chart


class NumericalXAxis(BaseAxes, NumericalXMixin, CategoricalYMixin):
    """Axis class for numerical X and categorical Y axes"""

    def __init__(self, chart):
        super(NumericalXAxis, self).__init__(chart)
        self._chart.style._apply_settings('categorical_yaxis')


class NumericalYAxis(BaseAxes, CategoricalXMixin, NumericalYMixin):
    """Axis class for numerical Y and categorical X axes"""

    def __init__(self, chart):
        super(NumericalYAxis, self).__init__(chart)
        self._chart.style._apply_settings('categorical_xaxis')


class NumericalXYAxes(BaseAxes, NumericalXMixin, NumericalYMixin):
    """Axis class for numerical X and Y axes."""


class DatetimeXNumericalYAxes(BaseAxes, DatetimeXMixin, NumericalYMixin):
    """Axis class for datetime X and numerical Y axes."""


class CategoricalXYAxes(BaseAxes, CategoricalXMixin, CategoricalYMixin):
    """Axis class for categorical X and Y axes."""

    def __init__(self, chart):
        super(CategoricalXYAxes, self).__init__(chart)
        self._chart.style._apply_settings('categorical_xyaxis')

# -*- coding: utf-8 -*-
#
# Copyright (c) 2017-2018 Spotify AB
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Module for chart callouts.
"""

import bokeh
from chartify._core import colors
from chartify._core.axes import DatetimeXNumericalYAxes


class Callout:
    """Class for adding callouts to the chart."""

    def __init__(self, chart):
        self._chart = chart

    def line(self,
             location,
             orientation='width',
             line_color='black',
             line_dash='solid',
             line_width=2,
             line_alpha=1.0):
        """Add line callout to the chart.
        Args:
            location (numeric):
            orientation (str, optional): (default: 'width')
                - 'width'
                - 'height'
            line_color (str, optional): Color name or hex value.
                See chartify.color_palettes.show() for available color names.
            line_dash (str, optional): Dash style for the line. One of:
                - 'solid'
                - 'dashed'
                - 'dotted'
                - 'dotdash'
                - 'dashdot'
            line_width (int, optional): Width of the line
            line_alpha (float, optional): Alpha of the line. Between 0 and 1.
        Returns:
            Current chart object
        """
        # Convert datetime values to epoch if datetime axis.
        if isinstance(self._chart.axes,
                      DatetimeXNumericalYAxes) and orientation == 'height':
            location = self._chart.axes._convert_timestamp_to_epoch_ms(location)
        line_color = colors.Color(line_color).get_hex_l()
        location_units = 'data'
        span = bokeh.models.Span(
            location=location,
            dimension=orientation,
            line_color=line_color,
            line_dash=line_dash,
            line_width=line_width,
            location_units=location_units,
            line_alpha=line_alpha)
        self._chart.figure.add_layout(span)
        return self._chart

    def line_segment(self,
                     x_start,
                     y_start,
                     x_end,
                     y_end,
                     line_color='black',
                     line_dash='solid',
                     line_width=2,
                     line_alpha=1.0):
        """Add line segment callout to the chart.
        Args:
            x_start (numeric)
            y_start (numeric)
            x_end (numeric)
            y_end (numeric)
            line_color (str): Color name or hex value.
                See chartify.color_palettes.show() for available color names.
            line_dash (str, optional): Dash style for the line. One of:
                - 'solid'
                - 'dashed'
                - 'dotted'
                - 'dotdash'
                - 'dashdot'
            line_width (int, optional): Width of the line
            line_alpha (float, optional): Alpha of the line. Between 0 and 1.
        Returns:
            Current chart object
        """
        # Convert datetime values to epoch if datetime axis.
        if isinstance(self._chart.axes, DatetimeXNumericalYAxes):
            x_start = self._chart.axes._convert_timestamp_to_epoch_ms(x_start)
            x_end = self._chart.axes._convert_timestamp_to_epoch_ms(x_end)
        line_color = colors.Color(line_color).get_hex_l()
        segment = bokeh.models.Arrow(
            x_start=x_start,
            y_start=y_start,
            x_end=x_end,
            y_end=y_end,
            end=None,
            start=None,
            line_color=line_color,
            line_width=line_width,
            line_dash=line_dash,
            line_alpha=line_alpha)

        self._chart.figure.add_layout(segment)
        return self._chart

    def box(self,
            top=None,
            bottom=None,
            left=None,
            right=None,
            alpha=.2,
            color='red'):
        """Add box callout to the chart.
        Args:
            top (numeric, optional): Top edge of the box.
            bottom (numeric, optional): Bottom edge of the box.
            left (numeric, optional): Left edge of the box.
            right (numeric, optional): Right edge of the box.
            alpha (float, optional): 0.2
            color (str): Color name or hex value.
                See chartify.color_palettes.show() for available color names.
        Note:
            The box will extend to the edge if the corresponding position
            argument is omitted.
        Returns:
            Current chart object
        """
        # Convert datetime values to epoch if datetime axis.
        if isinstance(self._chart.axes, DatetimeXNumericalYAxes):
            if left is not None:
                left = self._chart.axes._convert_timestamp_to_epoch_ms(left)
            if right is not None:
                right = self._chart.axes._convert_timestamp_to_epoch_ms(right)
        color = colors.Color(color).get_hex_l()
        box = bokeh.models.BoxAnnotation(
            top=top,
            bottom=bottom,
            left=left,
            right=right,
            fill_alpha=alpha,
            fill_color=color)
        self._chart.figure.add_layout(box)
        return self._chart

    def text(self,
             text,
             x,
             y,
             text_color='black',
             text_align='left',
             font_size='1em',
             angle=0):
        """Add text callout to the chart.
        Note:
            Use `\n` within text for newlines.
        Args:
            x (numeric): x location of the text.
            y (numeric, optional): y location of the text.
            text_color (str): Color name or hex value.
                See chartify.color_palettes.show() for available color names.
            text_align (str: 'left', 'right', 'center'): Text alignment.
            font_size (str): Font size.
            angle (int, 0 to 360): Angle in degrees from horizontal. Default: 0
        Returns:
            Current chart object
        """
        # Convert datetime values to epoch if datetime axis.
        if isinstance(self._chart.axes, DatetimeXNumericalYAxes):
            x = self._chart.axes._convert_timestamp_to_epoch_ms(x)
        text_color = colors.Color(text_color).get_hex_l()
        source = bokeh.models.ColumnDataSource({
            'text': [text],
            'x': [x],
            'y': [y]
        })
        text_font = self._chart.style._get_settings('text_callout_and_plot')[
            'font']
        self._chart.figure.text(
            x='x',
            y='y',
            text='text',
            text_color=text_color,
            text_align=text_align,
            angle=angle,
            angle_units='deg',
            text_font=text_font,
            source=source,
            text_font_size=font_size)
        return self._chart

# -*- coding: utf-8 -*-
#
# Copyright (c) 2017-2018 Spotify AB
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
"""
from collections import OrderedDict
from io import BytesIO
import tempfile
import warnings

import bokeh
import bokeh.plotting
from bokeh.embed import file_html

from bokeh.resources import INLINE
from IPython.display import display
from PIL import Image
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

from chartify._core.style import Style
from chartify._core.axes import BaseAxes
from chartify._core.plot import BasePlot
from chartify._core.callout import Callout
from chartify._core.options import options


class Chart:
    """Class Docstring
    - Styling (.style)
    - Plotting (.plot)
    - Callouts (.callout)
    - Axes (.axes)
    - Bokeh figure (.figure)
    """

    def __init__(self,
                 blank_labels=options.get_option('chart.blank_labels'),
                 layout='slide_100%',
                 x_axis_type='linear',
                 y_axis_type='linear'):
        """Create a chart instance.
        Args:
            blank_labels (bool): When true removes the title,
                subtitle, axes, and source labels from the chart.
                Default False.
            layout (str): Change size & aspect ratio of the chart for
                fitting into slides.
                - 'slide_100%'
                - 'slide_75%'
                - 'slide_50%'
                - 'slide_25%'
            x_axis_type (enum, str): Type of data plotted on the X-axis.
                - 'linear':
                - 'log':
                - 'datetime': Use for datetime formatted data.
                - 'categorical':
                - 'density'
            y_axis_type (enum, str): Type of data plotted on the Y-axis.
                - 'linear':
                - 'log':
                - 'categorical':
                - 'density'
        Note:
            Combination of x_axis_type and y_axis_type will determine the
            plotting methods available.
        """
        # Validate axis type input
        valid_x_axis_types = [
            'linear', 'log', 'datetime', 'categorical', 'density'
        ]
        valid_y_axis_types = ['linear', 'log', 'categorical', 'density']
        if x_axis_type not in valid_x_axis_types:
            raise ValueError('x_axis_type must be one of {options}'.format(
                options=valid_x_axis_types))
        if y_axis_type not in valid_y_axis_types:
            raise ValueError('y_axis_type must be one of {options}'.format(
                options=valid_y_axis_types))

        self._x_axis_type, self._y_axis_type = x_axis_type, y_axis_type

        self._blank_labels = options._get_value(blank_labels)
        self.style = Style(self, layout)
        self.figure = self._initialize_figure(self._x_axis_type,
                                              self._y_axis_type)
        self.style._apply_settings('chart')
        self.plot = BasePlot._get_plot_class(self._x_axis_type,
                                             self._y_axis_type)(self)
        self.callout = Callout(self)
        self.axes = BaseAxes._get_axis_class(self._x_axis_type,
                                             self._y_axis_type)(self)
        self._source = self._add_source_to_figure()
        self._subtitle_glyph = self._add_subtitle_to_figure()
        self.figure.toolbar.logo = None  # Remove bokeh logo from toolbar.
        # Reverse the order of vertical legends. Used with stacked plot types
        # to ensure that the stack order is consistent with the legend order.
        self._reverse_vertical_legend = False
        # Logos disabled for now.
        # self.logo = Logo(self)
        # Set default for title
        title = """ch.set_title('Takeaway')"""
        if self._blank_labels:
            title = ""
        self.set_title(title)

    def __repr__(self):
        return """
chartify.Chart(blank_labels={blank_labels},
layout='{layout}',
x_axis_type='{x_axis_type}',
y_axis_type='{y_axis_type}')
""".format(blank_labels=self._blank_labels,
           layout=self.style._layout,
           x_axis_type=self._x_axis_type,
           y_axis_type=self._y_axis_type)

    def _initialize_figure(self, x_axis_type, y_axis_type):
        x_range, y_range = None, None
        if x_axis_type == 'categorical':
            x_range = []
            x_axis_type = 'auto'
        if y_axis_type == 'categorical':
            y_range = []
            y_axis_type = 'auto'
        if x_axis_type == 'density':
            x_axis_type = 'linear'
        if y_axis_type == 'density':
            y_axis_type = 'linear'
        figure = bokeh.plotting.figure(
            x_range=x_range,
            y_range=y_range,
            y_axis_type=y_axis_type,
            x_axis_type=x_axis_type,
            plot_width=self.style.plot_width,
            plot_height=self.style.plot_height,
            tools='save',
            # toolbar_location='right',
            active_drag=None)
        return figure

    def _add_subtitle_to_figure(self, subtitle_text=None):
        """Create the subtitle glyph and add it to the bokeh figure."""
        if subtitle_text is None:
            subtitle_text = """ch.set_subtitle('Data Description')"""
        if self._blank_labels:
            subtitle_text = ""
        subtitle_settings = self.style._get_settings('subtitle')
        _subtitle_glyph = bokeh.models.Title(
            text=subtitle_text,
            align=subtitle_settings['subtitle_align'],
            text_color=subtitle_settings['subtitle_text_color'],
            text_font_size=subtitle_settings['subtitle_text_size'],
            text_font=subtitle_settings['subtitle_text_font'])
        self.figure.add_layout(_subtitle_glyph,
                               subtitle_settings['subtitle_location'])
        return _subtitle_glyph

    def _add_source_to_figure(self):
        """Create the source glyph and add it to the bokeh figure."""
        source_text = """ch.set_source_label('Source')"""
        if self._blank_labels:
            source_text = ""
        source_text_color = '#898989'
        source_font_size = '10px'
        _source = bokeh.models.Label(
            x=self.style.plot_width * .9,
            y=-55,
            x_units='screen',
            y_units='screen',
            level='overlay',
            text=source_text,
            text_color=source_text_color,
            text_font_size=source_font_size,
            text_align='right',
            name='subtitle')
        self.figure.add_layout(_source)
        return _source

    @property
    def data(self):
        """Return a list of dictionaries of the data that have be plotted on the chart.
        Note:
            The format will depend on the types of plots that have been added.
        """
        datasources = self.figure.select({
            'type': bokeh.models.ColumnDataSource
        })
        # Extract the data attribute from the ColumnDataSource object
        # and place in a list.
        datasources_list = list(map(lambda x: x.data, datasources))
        return datasources_list

    @property
    def source_text(self):
        """str: Data source of the chart."""
        return self._source.text

    def set_source_label(self, source):
        """Set the chart data source.
        Args:
            source (str): Data source.
        Returns:
            Current chart object
        """
        self._source.text = source
        return self

    @property
    def title(self):
        """str: Title text of the chart."""
        return self.figure.title.text

    def set_title(self, title):
        """Set the chart title.
        Args:
            title (str): Title text.
        Returns:
            Current chart object
        """
        self.figure.title.text = title
        return self

    @property
    def subtitle(self):
        """str: Subtitle text of the chart."""
        return self._subtitle_glyph.text

    def set_subtitle(self, subtitle):
        """Set the chart subtitle.
        Args:
            subtitle (str): Subtitle text.
        Note:
            Set value to "" to remove subtitle.
        Returns:
            Current chart object
        """
        self._subtitle_glyph.text = subtitle
        return self

    @property
    def legend_location(self):
        """str: Legend location."""
        return self.figure.legend[0].location

    def set_legend_location(self, location, orientation='horizontal'):
        """Set the legend location.
        Args:
            location (str or tuple): Legend location. One of:
            - Outside of the chart: 'outside_top', 'outside_bottom',
                  'outside_right'
            - Within the chart area: 'top_left', 'top_center',
                  'top_right', 'center_left', 'center', 'center_right',
                  'bottom_left', 'bottom_center', 'bottom_right'
            - Coordinates: Tuple(Float, Float)
            - None: Removes the legend.
            orientation (str): 'horizontal' or 'vertical'
        Returns:
            Current chart object
        """

        def add_outside_legend(legend_location, layout_location):
            self.figure.legend.location = legend_location
            if not self.figure.legend:
                warnings.warn(
                    """
                    Legend location will not apply.
                    Set the legend after plotting data.
                    """, UserWarning)
                return self
            new_legend = self.figure.legend[0]
            new_legend.plot = None
            new_legend.orientation = orientation
            self.figure.add_layout(new_legend, layout_location)

        if location == 'outside_top':
            add_outside_legend('top_left', 'above')
            # Re-render the subtitle so that it appears over the legend.
            subtitle_index = self.figure.renderers.index(self._subtitle_glyph)
            self.figure.renderers.pop(subtitle_index)
            self._subtitle_glyph = self._add_subtitle_to_figure(
                self._subtitle_glyph.text)
        elif location == 'outside_bottom':
            add_outside_legend('bottom_center', 'below')
        elif location == 'outside_right':
            add_outside_legend('top_left', 'right')
        elif location is None:
            self.figure.legend.visible = False
        else:
            self.figure.legend.location = location
            self.figure.legend.orientation = orientation

        vertical = self.axes._vertical
        # Reverse the legend order
        if self._reverse_vertical_legend:
            if orientation == 'vertical' and vertical:
                self.figure.legend[0].items = list(
                    reversed(self.figure.legend[0].items))
        return self

    def show(self, format='html'):
        """Show the chart.
        Args:
            format (str):
                - 'html': Output chart as HTML.
                    Renders faster and allows for interactivity.
                    Charts saved as HTML in a Jupyter notebooks
                    WILL NOT display on Github.
                    Logos will not display on HTML charts.
                    Recommended when drafting plots.
                - 'png': Output chart as PNG.
                    Easy to copy+paste into slides.
                    Will render logos.
                    Recommended when the plot is in a finished state.
                """
        self._set_toolbar_for_format(format)

        if format == 'html':
            return bokeh.io.show(self.figure)
        elif format == 'png':
            image = self._figure_to_png()
            # Need to re-enable this when logos are added back.
            # image = self.logo._add_logo_to_image(image)
            return display(image)

    def save(self, filename, format='html'):
        """Save the chart.
        Args:
            filename (str): Name of output file.
            format (str):
                - 'html': Output chart as HTML.
                    Renders faster and allows for interactivity.
                    Charts saved as HTML in a Jupyter notebook WILL NOT display
                    on Github.
                    Logos will not display on HTML charts.
                    Recommended when drafting plots.
                - 'png': Output chart as PNG.
                    Easy to paste into google slides.
                    Recommended when the plot is in a finished state.
                    Will render logos.
        """
        self._set_toolbar_for_format(format)

        if format == 'html':
            bokeh.io.saving.save(
                self.figure,
                filename=filename,
                resources=INLINE,
                title='Chartify chart.')
        elif format == 'png':
            image = self._figure_to_png()
            # Need to re-enable this when logos are added back.
            # image = self.logo._add_logo_to_image(image)
            image.save(filename)

        print('Saved to {filename}'.format(filename=filename))

        return self

    def _set_toolbar_for_format(self, format):
        if format == 'html':
            self.figure.toolbar_location = 'right'
        elif format == 'png':
            self.figure.toolbar_location = None
        elif format is None:  # If format is None the chart won't be shown.
            pass
        else:
            raise ValueError(
                """Invalid format. Valid options are 'html' or 'png'.""")

    def _figure_to_png(self):
        """Convert figure object to PNG
        Bokeh can only save figure objects as html.
        To convert to PNG the HTML file is opened in a headless browser.
        """
        # Initialize headless browser options
        options = Options()
        options.add_argument("window-size={width},{height}".format(
            width=self.style.plot_width, height=self.style.plot_height))
        options.add_argument("start-maximized")
        options.add_argument("disable-infobars")
        options.add_argument("disable-gpu")
        options.add_argument('no-sandbox')  # Required for use in docker.
        options.add_argument("--disable-extensions")
        options.add_argument('--headless')
        options.add_argument('--hide-scrollbars')
        driver = webdriver.Chrome(options=options)
        # Save figure as HTML
        html = file_html(self.figure, resources=INLINE, title="")
        fp = tempfile.NamedTemporaryFile(
            'w', prefix='chartify', suffix='.html', encoding='utf-8')
        fp.write(html)
        fp.flush()
        # Open html file in the browser.
        driver.get("file:///" + fp.name)
        driver.execute_script("document.body.style.margin = '0px';")
        png = driver.get_screenshot_as_png()
        driver.quit()
        fp.close()
        # Resize image if necessary.
        image = Image.open(BytesIO(png))
        target_dimensions = (self.style.plot_width, self.style.plot_height)
        if image.size != target_dimensions:
            image = image.resize(target_dimensions, resample=Image.LANCZOS)
        return image


class Logo:

    def __init__(self, chart):
        self._chart = chart
        self._logo_image = None
        self._path = options.get_option('config.logos_path')
        self._logo_file_mapping = {}
        self._logo_file_mapping = OrderedDict(
            sorted(list(self._logo_file_mapping.items()), key=lambda t: t[0]))

    def _add_logo_to_image(self, image):
        """If the logo is set then add it to the chart image."""
        if self._logo_image is None:
            return image

        x_dim = image.getbbox()[2]
        width = self._logo_image.getbbox()[2]
        padding = 10
        coords = (x_dim - width - padding, 0 + padding)
        image.paste(self._logo_image, coords, self._logo_image)
        return image

    def _resize_logo(self, logo_image):

        logo_width, logo_height = logo_image.size

        # TODO smart scaling of logos
        target_height = int(self._chart.style.plot_height * .1)

        if logo_width == logo_height:
            logo_image = logo_image.resize(
                (target_height, target_height), resample=Image.LANCZOS)
        else:
            logo_width_to_height = logo_width * 1.0 / logo_height
            logo_image = logo_image.resize(
                (int(logo_width_to_height * target_height), target_height),
                resample=Image.LANCZOS)
        return logo_image

    def show_logo_options(self):
        for name, filename in self._logo_file_mapping.items():
            logo_image = Image.open(self._path + filename)
            display(name)
            display(self._resize_logo(logo_image))

    def set_logo(self, logo=None):
        """Add logo to the chart.
        Notes:
            Use .show_logo_options() to see available logos.
            Logo will only appear when .show('png') is used.
        """
        try:
            filename = self._logo_file_mapping[logo]
        except KeyError:
            raise KeyError(
                'Must supply a valid logo name: {valid_options}'.format(
                    valid_options=list(self._logo_file_mapping.keys())))

        logo_image = Image.open(self._path + filename)

        logo_image = self._resize_logo(logo_image)

        self._logo_image = logo_image

# -*- coding: utf-8 -*-
#
# Copyright (c) 2017-2018 Spotify AB
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from collections import OrderedDict
from bokeh import palettes
from IPython.core.display import HTML
import colour
import yaml

from chartify._core.options import options


class CustomColors:
    def __init__(self):

        config_filename = options.get_option('config.colors')
        try:
            self.colors = self.from_yaml(config_filename)
        except FileNotFoundError:
            self.colors = {
                (232, 232, 232): 'Light Grey',
                (83, 88, 95): 'Dark Grey',
            }

    def to_yaml(self, filename):
        """Write colors to a yaml file"""
        with open(filename, 'w') as outfile:
            yaml.dump(self.colors, outfile, default_flow_style=False)

    def from_yaml(self, filename):
        """Load colors from yaml file"""
        return yaml.load(open(filename))

    def overwrite_colors(self):
        """Overwrite colors in the colour module with custom colors."""
        if not self.colors:
            return

        for color_rgb, color_name in self.colors.items():
            # Remove color from default names if it already exits.
            color_name = color_name.lower()
            if color_name in list(colour.COLOR_NAME_TO_RGB.keys()):
                delete_color_value = colour.COLOR_NAME_TO_RGB[color_name]
                del colour.RGB_TO_COLOR_NAMES[delete_color_value]
                del colour.COLOR_NAME_TO_RGB[color_name]
            colour.RGB_TO_COLOR_NAMES[color_rgb] = [color_name]

        colour.COLOR_NAME_TO_RGB = dict(
            (name.lower(), rgb)
            for rgb, names in list(colour.RGB_TO_COLOR_NAMES.items())
            for name in names)


# Load custom colors.
CustomColors().overwrite_colors()


class Color(colour.Color):
    DISPLAY_HEIGHT = '20px'
    DISPLAY_WIDTH = '200px'

    def _html(self):
        return """<div style="width: {width};
                        height: {height};
                        background-color: {color};
                        color: {foreground_color};
                        padding: 2px;
                        margin: 2px;
                        display: block;">'{name}',</div>""".format(
            height=self.DISPLAY_HEIGHT,
            width=self.DISPLAY_WIDTH,
            color=self.hex,
            name=self.get_web(),
            foreground_color=self.foreground_color())

    def show(self):
        return HTML(self._html())

    def foreground_color(self):
        return Color('#000000') if self.get_luminance() > 0.4 else Color(
            '#ffffff')

    def linear_gradient(self, finish_color, n=10):
        """Return a gradient list of (n) colors between
        two colors."""
        # Starting and ending colors in RGB form
        s = self.get_rgb()
        f = finish_color.get_rgb()
        # Initilize a list of the output colors with the starting color
        RGB_list = [s]
        # Calcuate a color at each evenly spaced value of t from 1 to n
        for t in range(1, n):
            # Interpolate RGB vector for color at the current value of t
            curr_vector = [(s[j] + (float(t) / (n - 1)) * (f[j] - s[j]))
                           for j in range(3)]
            # Add it to our list of output colors
            RGB_list.append(curr_vector)
        RGB_list = [Color(rgb=r) for r in RGB_list]
        return RGB_list


class ColorPalette:
    def __init__(self, colors, palette_type=None, name=None):
        self.colors = colors
        self.name = name
        self.palette_type = palette_type

    def _html(self):
        return """<div style='padding: 10px; margin: 5px;'>
                  <h3>{name}</h3>{colors}</div>""".format(
            colors=' '.join([c._html() for c in self.colors]), name=self.name)

    def show(self):
        return HTML(self._html())

    @classmethod
    def from_hex_list(cls, colors, palette_type=None, name=None):
        """Create ColorPalette from list of color hex values or color names.
        Args:
            colors (list of str): List of color hex values or names.
            palette_type (str, optional): Type of palette:
                'sequential', 'diverging', 'categorical'
            name (str, optional): Name of color palette.
        """
        hex_list = [Color(color) for color in colors]
        return cls(hex_list, palette_type, name)

    def sort_by_hue(self, ascending=True):
        new_palette = ColorPalette.from_hex_list(
            colors=self.colors[:],
            palette_type=self.palette_type,
            name=self.name)
        new_palette.colors.sort(key=lambda x: x.get_hue(), reverse=ascending)
        return new_palette

    def sort_by_luminance(self, ascending=True):
        new_palette = ColorPalette.from_hex_list(
            colors=self.colors[:],
            palette_type=self.palette_type,
            name=self.name)
        new_palette.colors.sort(
            key=lambda x: x.get_luminance(), reverse=ascending)
        return new_palette

    def sort_by_saturation(self, ascending=True):
        new_palette = ColorPalette.from_hex_list(
            colors=self.colors[:],
            palette_type=self.palette_type,
            name=self.name)
        new_palette.colors.sort(
            key=lambda x: x.get_saturation(), reverse=ascending)
        return new_palette

    def expand_palette(self, target_color_count):
        """Linearly expand the color palette up to the target color count."""
        palette_color_count = len(self.colors)
        if target_color_count <= palette_color_count:
            return self
        target_color_count = target_color_count - 1
        extrapolation_count = [
            target_color_count // (palette_color_count - 1)
        ] * (palette_color_count - 1)
        for i in range(target_color_count % (palette_color_count - 1)):
            extrapolation_count[i] += 1

        extrapolated_palette = []
        for i, count in enumerate(extrapolation_count):
            extrapolated_palette.extend(self.colors[i].linear_gradient(
                self.colors[i + 1], count + 1)[:-1])
        extrapolated_palette.extend([self.colors[-1]])

        return ColorPalette.from_hex_list(
            colors=extrapolated_palette,
            palette_type=self.palette_type,
            name=self.name)

    def shift_palette(self, target_color, percent=10):
        """Shift each color in the palette toward the given target color.
        Args:
            target_color (str): Color hex value or name.
            percent (int): Distance to shift the current palette toward the
                target color.
        """
        shifted_colors = [
            color.linear_gradient(Color(target_color), n=100)[percent - 1]
            for color in self.colors
        ]
        return ColorPalette.from_hex_list(
            colors=shifted_colors,
            palette_type=self.palette_type,
            name=self.name)

    def to_hex_list(self):
        """Return list of hex values of colors in the palette."""
        return [color.get_hex_l() for color in self.colors]

    def __getitem__(self, key):
        if isinstance(key, str):
            color_slice = Color(key)
        else:
            color_slice = self.colors[:][key]

        if isinstance(color_slice, Color):
            color_slice = [color_slice]

        return ColorPalette(
            colors=color_slice, palette_type=self.palette_type, name=self.name)

    def __repr__(self):
        return "Color Palette '{name}': \n{colors}".format(
            name=self.name,
            colors='\n'.join(
                ["'{},'".format(color.get_web()) for color in self.colors]))


class ColorPalettes:
    def __init__(self):
        self._palettes = OrderedDict()

        config_filename = options.get_option('config.color_palettes')
        try:
            self._from_yaml(config_filename)
        except FileNotFoundError:
            pass

    def show(self):
        return HTML("""<h2>Color Palettes</h2><div>{palettes}</div>""".format(
            palettes=' '.join([v._html() for k, v in self._palettes.items()])))

    def _add_palette(self, palette):
        self._palettes[palette.name.lower()] = palette

    def __getitem__(self, item):
        try:
            return self._palettes[item.lower()]
        except (KeyError):
            raise KeyError("""Invalid color palette name.
                See chartify.color_palettes.show() for
                the available color palettes.""")

    def __repr__(self):
        return "Color Palettes: \n{palettes}".format(palettes='\n'.join([
            "'{}'".format(palette.name)
            for key, palette in self._palettes.items()
        ]))

    def _to_yaml(self, filename):
        """Write the color palettes to a yaml file"""
        palette_list = []
        for palette in self._palettes.values():
            hex_color_list = [color.get_hex_l() for color in palette.colors]
            palette_list.append(
                [hex_color_list, palette.palette_type, palette.name])

        with open(filename, 'w') as outfile:
            yaml.dump(palette_list, outfile, default_flow_style=False)

    def _from_yaml(self, filename):
        """Load color palettes from a yaml file"""
        palette_list = yaml.load(open(filename))
        for palette in palette_list:
            hex_color_list, palette_type, name = palette
            self._add_palette(
                ColorPalette.from_hex_list(
                    colors=hex_color_list,
                    palette_type=palette_type,
                    name=name))

    def create_palette(self, colors, palette_type, name):
        """Create ColorPalette from list of color hex values or color names.
        Args:
        colors (list of str): List of color hex values or names.
        palette_type (str, optional): Type of palette:
            'sequential', 'diverging', 'categorical'
        name (str, optional): Name of color palette.
        """
        new_palette = ColorPalette.from_hex_list(
            colors=colors,
            palette_type=palette_type,
            name=name,
            )
        self._add_palette(new_palette)


color_palettes = ColorPalettes()

# See available bokeh palettes here
# https://bokeh.pydata.org/en/latest/docs/reference/palettes.html
color_palettes._add_palette(
    ColorPalette.from_hex_list(
        name="Category20",
        palette_type='categorical',
        # Reorder the palette to prioritize the bolder colors first.
        colors=palettes.Category20[20][::2] + palettes.Category20[20][1::2]))

color_palettes._add_palette(
    ColorPalette.from_hex_list(
        name="Category10",
        palette_type='categorical',
        colors=palettes.Category10[10]))

color_palettes._add_palette(
    ColorPalette.from_hex_list(
        name="Colorblind",
        palette_type='categorical',
        colors=palettes.Colorblind[8]))

color_palettes._add_palette(
    ColorPalette.from_hex_list(
        name="Dark2", palette_type='categorical', colors=palettes.Dark2[8]))

color_palettes._add_palette(
    ColorPalette.from_hex_list(
        name="Pastel1", palette_type='categorical',
        colors=palettes.Pastel1[9]))

color_palettes._add_palette(
    ColorPalette.from_hex_list(
        name="RdBu", palette_type='diverging', colors=palettes.RdBu[3]))

color_palettes._add_palette(
    ColorPalette.from_hex_list(
        name="RdGy", palette_type='diverging', colors=palettes.RdGy[5]))

color_palettes._add_palette(
    ColorPalette.from_hex_list(
        name="Greys",
        palette_type='sequential',
        colors=palettes.Greys[9][::-1][2:]))

color_palettes._add_palette(
    ColorPalette.from_hex_list(
        name="Greens",
        palette_type='sequential',
        colors=palettes.Greens[9][::-1][2:]))

color_palettes._add_palette(
    ColorPalette.from_hex_list(
        name="Blues",
        palette_type='sequential',
        colors=palettes.Blues[9][::-1][2:]))

color_palettes._add_palette(
    ColorPalette.from_hex_list(
        name="Reds",
        palette_type='sequential',
        colors=palettes.Reds[9][::-1][2:]))

color_palettes._add_palette(
    ColorPalette.from_hex_list(
        name="Oranges",
        palette_type='sequential',
        colors=palettes.Oranges[9][::-1][2:]))

all_colors = ColorPalette(
    name='All colors',
    colors=[
        Color(rgb=[c / 255. for c in color_tuple])
        for color_tuple in colour.RGB_TO_COLOR_NAMES
    ])
all_colors = all_colors.sort_by_hue()
color_palettes._add_palette(all_colors)


# -*- coding: utf-8 -*-
#
# Copyright (c) 2017-2018 Spotify AB
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from collections import OrderedDict
import os
from pathlib import Path
import yaml


class ChartifyOptions:
    def __init__(self):

        try:
            options_path = os.environ['CHARTIFY_CONFIG_DIR']
        except KeyError:
            home_path = str(Path.home())
            options_path = home_path + '/.chartify/'
        self._options = OrderedDict({
            'style.color_palette_categorical':
            OptionValue('Category20'),
            'style.color_palette_sequential':
            OptionValue('Blues'),
            'style.color_palette_diverging':
            OptionValue('RdBu'),
            'style.color_palette_accent':
            OptionValue('Category20'),
            'style.color_palette_accent_default_color':
            OptionValue('grey'),
            'chart.blank_labels':
            OptionValue(False),
            'config.logos_path':
            OptionValue(options_path + 'logos/'),
            'config.options':
            OptionValue(options_path + 'options_config.yaml'),
            'config.style_settings':
            OptionValue(options_path + 'style_settings_config.yaml'),
            'config.colors':
            OptionValue(options_path + 'colors_config.yaml'),
            'config.color_palettes':
            OptionValue(options_path + 'color_palettes_config.yaml')
        })

        config_filename = self.get_option('config.options')
        try:
            self._from_yaml(config_filename)
        except FileNotFoundError:
            pass

    def get_option(self, option_name):
        """Return the value of the given option"""
        return self._options[option_name].value

    def set_option(self, option_name, option_value):
        """Set the default value of the specified option.
        Available options:
            'style.color_palette_categorical': (str)
                Color palette for categorical palette types.
            'style.color_palette_sequential': (str)
                Color palette for sequential palette types.
            'style.color_palette_diverging': (str)
                Color palette for diverging palette types.
            'style.color_palette_accent': (str)
                Color palette for assigning color to specific values.
            'style.color_palette_accent_default_color': (str)
                Default color of values in the 'color_column' that
                    are not accented.
                Default: 'light grey'
            'chart.blank_labels': boolean
                If False, chartify.Chart objects populate the default
                    chart labels with helper text.
                Default: False
        """
        self._options[option_name].value = option_value

    @staticmethod
    def _get_value(option_value):
        if isinstance(option_value, OptionValue):
            return option_value.value
        else:
            return option_value

    def _to_yaml(self, filename):
        """Write the options to a yaml file"""
        with open(filename, 'w') as outfile:
            yaml.dump(self._options, outfile, default_flow_style=False)

    def _from_yaml(self, filename):
        """Load options from a yaml file.
        Overwrites any options that are specified in the yaml file.
        """
        yaml_options = yaml.load(open(filename))
        self._options.update(yaml_options)


class OptionValue:
    def __init__(self, value):
        self.value = value

    def __repr__(self):
        return '%s' % self.value


options = ChartifyOptions()

import bokeh
import pandas as pd
import numpy as np
from chartify._core.colors import Color, color_palettes
from chartify._core.axes import NumericalYMixin, NumericalXMixin

from scipy.stats.kde import gaussian_kde


class BasePlot:
    """Base for all plot classes."""

    def __init__(self, chart):
        self._chart = chart

    @staticmethod
    def _axis_format_precision(max_value, min_value):
        difference = abs(max_value - min_value)
        precision = abs(int(np.floor(np.log10(difference)))) + 1
        zeros = ''.join(['0']*precision)
        return "0,0.[{}]".format(zeros)

    @classmethod
    def _get_plot_class(cls, x_axis_type, y_axis_type):
        if x_axis_type == 'categorical' and y_axis_type == 'categorical':
            return PlotCategoricalXY
        elif x_axis_type not in ('categorical',
                                 'density') and y_axis_type not in (
                                     'categorical', 'density'):
            return PlotNumericXY
        elif x_axis_type == 'density' and y_axis_type == 'density':
            return PlotDensityXY
        elif x_axis_type == 'datetime' and y_axis_type == 'density':
            raise NotImplementedError(
                "Plot for this axis type combination not yet implemented.")
        elif x_axis_type == 'density' or y_axis_type == 'density':
            return PlotNumericDensityXY
        else:
            return PlotMixedTypeXY

    def _get_color_and_order(self,
                             data_frame,
                             color_column,
                             color_order,
                             categorical_columns=None):
        """
        Returns:
            colors: List of hex colors or factor_cmap.
            color_order: List of values for each color.
        """
        if color_column is None:
            colors = [self._chart.style.color_palette.next_color()]
            color_order = [None]
        else:
            # Determine color order or verify integrity of specified order.
            if color_order is None:
                color_order = sorted(data_frame[color_column].unique())
            else:
                # Check that all color factors are present in the color order.
                if not set(data_frame[color_column].unique()).issubset(
                        set(color_order)):
                    raise ValueError("""Color order must include
                                     all unique factors of variable `%s`.""" %
                                     color_column)

            next_colors = self._chart.style.color_palette.next_colors(
                color_order)
            if categorical_columns is None:  # Numeric data
                colors = next_colors
            else:
                # Color column must be in the categorical_columns
                try:
                    color_index = categorical_columns.index(color_column)
                except ValueError:
                    raise ValueError(
                        '''`color_column` must be present
                         in the `categorical_columns`'''
                    )
                color_order = [str(factor) for factor in color_order]
                colors = bokeh.transform.factor_cmap(
                    'factors',
                    palette=next_colors,
                    factors=color_order,
                    start=color_index,
                    end=color_index + 1,
                )
        return colors, color_order

    @staticmethod
    def _cannonical_series_name(series_name):
        if series_name is None:
            series_name = ''
        return 'Series:{}'.format(series_name)

    @staticmethod
    def _named_column_data_source(data_frame, series_name):
        """Ensure consistent naming of column data sources."""
        cannonical_series_name = BasePlot._cannonical_series_name(series_name)
        return bokeh.models.ColumnDataSource(
            data_frame, name=cannonical_series_name)

    def _cast_datetime_axis(self, data_frame, column):
        if self._chart._x_axis_type == 'datetime':
            if data_frame[column].dtype != 'datetime64[ns]':
                return data_frame.astype({column: 'datetime64[ns]'})
        return data_frame

    def __getattr__(self, item):
        """Override attribute error
        """
        raise AttributeError("""Plot `{}` not avaiable for the given Chart.
            Try changing the Chart parameters x_axis_type and y_axis_type.
            """.format(item))

    def _set_numeric_axis_default_format(self, data_frame,
                                         x_column=None, y_column=None):
        """Set numeric axis range based on the input data.
        """

        if isinstance(self._chart.axes, NumericalXMixin):
            # Warn user if they try to plot date data on a non-datetime axis.
            if data_frame[x_column].dtype == 'datetime64[ns]':
                raise ValueError("""Set chartify.Chart(x_axis_type='datetime')
                when plotting datetime data.""")
            # Warn user if they try to plot date data that hasn't been cast
            # to the proper dtype.
            elif data_frame[x_column].dtype == 'O':
                raise ValueError("""Attempting to plot `{}` on a numeric
                    axis. Ensure that chartify.Chart x_axis_type and y_axis_type
                    are set properly, or cast your input data appropriately.
                    """.format(x_column))

        if isinstance(self._chart.axes, NumericalXMixin):
            max_x_value = data_frame[x_column].max()
            min_x_value = data_frame[x_column].min()
            max_x_value, min_x_value = max(max_x_value, 0), min(min_x_value, 0)
            self._chart.axes.set_xaxis_tick_format(
                self._axis_format_precision(max_x_value,
                                            min_x_value)
                )

        if isinstance(self._chart.axes, NumericalYMixin):
            max_y_value = data_frame[y_column].max()
            min_y_value = data_frame[y_column].min()
            max_y_value, min_y_value = max(max_y_value, 0), min(min_y_value, 0)
            self._chart.axes.set_yaxis_tick_format(
                self._axis_format_precision(max_y_value,
                                            min_y_value)
                )


class PlotCategoricalXY(BasePlot):
    """Plot functions for categorical x & y axes:
    Methods:
        - heatmap
    """

    def heatmap(self,
                data_frame,
                x_column,
                y_column,
                color_column,
                text_column=None,
                color_palette='RdBu',
                reverse_color_order=False,
                text_color='white',
                text_format='{:,.2f}',
                color_value_min=None,
                color_value_max=None,
                color_value_range=100):
        """Heatmap.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            x_column (str): Column name to plot on the x axis.
            y_column (str): Column name to plot on the y axis.
            color_column (str): Column name of numerical type to plot on
                the color dimension.
            text_column (str or None): Column name of the text labels.
            color_palette (str, chartify.ColorPalette): Color palette to
                apply to the heatmap.
                See chartify.color_palettes.show() for available color palettes.
            reverse_color_order (bool): Reverse order of the color palette.
            text_color (str): Color name or hex value.
                See chartify.color_palettes.show() for available color names.
            text_format: Python string formatting to apply to the text labels.
            color_value_min (float): Minimum value for the color palette.
                If None, will default to the min value of the
                color_column dimension.
            color_value_max (float): Maximum value for the color palette.
                If None, will default to the max value of the
                color_column dimension.
            color_value_range (int): The size of the range of colors in
                the color palette.
                A larger color range will result in greater variation
                among the cell colors.
            """
        # Cast all categorical columns to strings
        # Plotting functions will break with non-str types.
        type_map = {column: str for column in [x_column, y_column]}
        self._chart.figure.x_range.factors = data_frame[x_column].astype(
            str).unique()
        self._chart.figure.y_range.factors = data_frame[y_column].astype(
            str).unique()

        cast_data = data_frame[[x_column, y_column,
                                color_column]].astype(type_map)

        source = self._named_column_data_source(cast_data, series_name=None)
        if text_color:
            text_color = Color(text_color).get_hex_l()
        if isinstance(color_palette, str):
            color_palette = color_palettes[color_palette]
        if reverse_color_order:
            color_palette = color_palette[::-1]
        color_palette = color_palette.expand_palette(color_value_range)
        color_palette = [c.get_hex_l() for c in color_palette.colors]

        # If not specified set the min and max value based on the data.
        if not color_value_min:
            color_value_min = data_frame[color_column].min()
        if not color_value_max:
            color_value_max = data_frame[color_column].max()
        mapper = bokeh.models.LinearColorMapper(
            palette=color_palette, low=color_value_min, high=color_value_max)
        self._chart.figure.rect(
            source=source,
            x=x_column,
            y=y_column,
            fill_color={
                'field': color_column,
                'transform': mapper
            },
            width=1,
            height=1,
            dilate=True,
            line_alpha=0)

        if text_column:
            text_font = self._chart.style._get_settings(
                'text_callout_and_plot')['font']
            formatted_text = data_frame[text_column].map(text_format.format)
            source.add(formatted_text, 'formatted_text')
            self._chart.figure.text(
                text='formatted_text',
                x=x_column,
                y=y_column,
                source=source,
                text_align='center',
                text_baseline='middle',
                text_color=text_color,
                text_font=text_font)
        return self._chart


class PlotNumericXY(BasePlot):
    """Plot functions for numeric x & y axes:
    Methods:
        - line
        - scatter
        - text
        - area
    """

    def line(self,
             data_frame,
             x_column,
             y_column,
             color_column=None,
             color_order=None,
             line_dash='solid',
             line_width=4,
             alpha=1.0):
        """Line Chart.
        Note:
            This method will not automatically sort the x-axis.
            Try sorting the axis if the line graph looks strange.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            x_column (str): Column name to plot on the x axis.
            y_column (str): Column name to plot on the y axis.
            color_column (str, optional): Column name to group by on
                the color dimension.
            color_order (list, optional): List of values within the
                'color_column' for specific sorting of the colors.
            line_dash (str, optional): Dash style for the line. One of:
                - 'solid'
                - 'dashed'
                - 'dotted'
                - 'dotdash'
                - 'dashdot'
            line_width (int, optional): Width of the line
            alpha (float): Alpha value.
        """
        settings = self._chart.style._get_settings('line_plot')
        line_cap = settings['line_cap']
        line_join = settings['line_join']

        colors, color_values = self._get_color_and_order(
            data_frame, color_column, color_order)

        self._set_numeric_axis_default_format(data_frame, x_column, y_column)

        for color_value, color in zip(color_values, colors):

            if color_column is None:  # Single line
                sliced_data = data_frame
            else:
                sliced_data = data_frame[data_frame[color_column] ==
                                         color_value]
            # Filter to only relevant columns.
            sliced_data = (
                sliced_data[
                    [col for col in sliced_data.columns
                        if col in (
                            x_column, y_column, color_column)]])

            cast_data = self._cast_datetime_axis(sliced_data, x_column)

            source = self._named_column_data_source(
                cast_data, series_name=color_value)

            color_value = str(
                color_value) if color_value is not None else color_value

            self._chart.figure.line(
                x=x_column,
                y=y_column,
                source=source,
                line_width=line_width,
                color=color,
                line_join=line_join,
                line_cap=line_cap,
                legend=color_value,
                line_dash=line_dash,
                alpha=alpha)

        # Set legend defaults if there are multiple series.
        if color_column is not None:
            self._chart.style._apply_settings('legend')

        return self._chart

    def scatter(self,
                data_frame,
                x_column,
                y_column,
                size_column=None,
                color_column=None,
                color_order=None,
                alpha=1.0,
                marker='circle'):
        """Scatter plot.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            x_column (str): Column name to plot on the x axis.
            y_column (str): Column name to plot on the y axis.
            size_column (str, optional): Column name of numerical values
                to plot on the size dimension.
            color_column (str, optional): Column name to group by on
                the color dimension.
            color_order (list, optional): List of values within the
                'color_column' for specific sorting of the colors.
            alpha (float): Alpha value.
            marker (str): marker type. Valid types:
                'asterisk', 'circle', 'circle_cross', 'circle_x', 'cross',
                'diamond', 'diamond_cross', 'hex', 'inverted_triangle',
                'square', 'square_x', 'square_cross', 'triangle',
                'x', '*', '+', 'o', 'ox', 'o+'
        """
        if size_column is None:
            size_column = 6

        colors, color_values = self._get_color_and_order(
            data_frame, color_column, color_order)

        self._set_numeric_axis_default_format(data_frame, x_column, y_column)

        for color_value, color in zip(color_values, colors):

            if color_column is None:  # Single series
                sliced_data = data_frame
            else:
                sliced_data = data_frame[data_frame[color_column] ==
                                         color_value]
            # Filter to only relevant columns.
            sliced_data = (
                sliced_data[
                    [col for col in sliced_data.columns
                        if col in (
                            x_column, y_column, size_column, color_column)]])
            cast_data = self._cast_datetime_axis(sliced_data, x_column)

            source = self._named_column_data_source(
                cast_data, series_name=color_value)

            color_value = str(
                color_value) if color_value is not None else color_value

            self._chart.figure.scatter(
                x=x_column,
                y=y_column,
                size=size_column,
                source=source,
                fill_color=color,
                legend=color_value,
                marker=marker,
                line_color=color,
                alpha=alpha)

        # Set legend defaults if there are multiple series.
        if color_column is not None:
            self._chart.style._apply_settings('legend')

        return self._chart

    def text(self,
             data_frame,
             x_column,
             y_column,
             text_column,
             color_column=None,
             color_order=None,
             font_size='1em',
             x_offset=0,
             y_offset=0,
             angle=0,
             text_color=None):
        """Text plot.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            x_column (str): Column name to plot on the x axis.
            y_column (str): Column name to plot on the y axis.
            text_column (str): Column name to plot as text labels.
            color_column (str, optional): Column name to group by on the
                color dimension.
            color_order (list, optional): List of values within the
                'color_column' for specific sorting of the colors.
            font_size (str, optional): Size of text.
            x_offset (int, optional): # of pixels for horizontal text offset.
                Can be negative. Default: 0.
            y_offset (int, optional): # of pixels for vertical text offset.
                Can be negative. Default: 0.
            angle (int): Degrees from horizontal for text rotation.
            text_color (str): Color name or hex value.
                See chartify.color_palettes.show() for available color names.
                If omitted, will default to the next color in the
                current color palette.
        """
        text_font = self._chart.style._get_settings('text_callout_and_plot')[
            'font']
        if text_color:
            text_color = Color(text_color).get_hex_l()
            colors, color_values = [text_color], [None]
        else:
            colors, color_values = self._get_color_and_order(
                data_frame, color_column, color_order)

        self._set_numeric_axis_default_format(data_frame, x_column, y_column)

        for color_value, color in zip(color_values, colors):

            if color_column is None:  # Single series
                sliced_data = data_frame
            else:
                sliced_data = data_frame[data_frame[color_column] ==
                                         color_value]
            # Filter to only relevant columns.
            sliced_data = (
                sliced_data[
                    [col for col in sliced_data.columns
                        if col in (
                            x_column, y_column, text_column, color_column)]])
            cast_data = self._cast_datetime_axis(sliced_data, x_column)

            source = self._named_column_data_source(
                cast_data, series_name=color_value)

            self._chart.figure.text(
                text=text_column,
                x=x_column,
                y=y_column,
                text_font_size=font_size,
                source=source,
                text_color=color,
                y_offset=y_offset,
                x_offset=x_offset,
                angle=angle,
                angle_units='deg',
                text_font=text_font)
        return self._chart

    def area(self,
             data_frame,
             x_column,
             y_column,
             second_y_column=None,
             color_column=None,
             color_order=None,
             stacked=False):
        """Area plot.
        Note:
            - When a single y_column is passed: Shade area between the
                y_values and zero.
            - Use `stacked` argument for stacked areas.
            - When both y_column and second_y_column are passed:
                Shade area between the two y_columns.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            x_column (str): Column name to plot on the x axis.
            y_column (str): Column name to plot on the y axis.
            second_y_column (str, optional): Column name to plot on
                the y axis.
            color_column (str, optional): Column name to group by on
                the color dimension.
            color_order (list, optional): List of values within the
                'color_column' for specific sorting of the colors.
            stacked (bool, optional): Stacked the areas.
                Only applicable with a single y_column.
                Default: False.
        """
        # Vertical option only applies to density plots
        vertical = self._chart.axes._vertical

        alpha = 0.2
        colors, color_values = self._get_color_and_order(
            data_frame, color_column, color_order)

        self._set_numeric_axis_default_format(data_frame, x_column, y_column)

        if color_column is not None:
            data_frame = (
                data_frame.set_index([x_column, color_column]).reindex(
                    index=pd.MultiIndex.from_product(
                        [data_frame[x_column].unique(),
                         data_frame[color_column].unique()],
                        names=[x_column, color_column]))
                .reset_index(drop=False)
                .fillna(0))

        if second_y_column is None and color_column is not None:
            last_y = np.zeros(data_frame.groupby(color_column).size().iloc[0])

        for color_value, color in zip(color_values, colors):
            if color_column is None:
                data = data_frame

                if second_y_column is None:
                    alpha = .8
                    y_data = np.hstack((data[y_column],
                                        np.zeros(len(data[y_column]))))
                else:
                    y_data = pd.concat(
                        [data[y_column], data[second_y_column][::-1]])

            else:

                data = data_frame[data_frame[color_column] == color_value]

                if second_y_column is None:
                    y_data = np.hstack((data[y_column].reset_index(drop=True),
                                        last_y[::-1]))

                    if stacked:
                        alpha = .8
                        next_y = last_y + data[y_column].reset_index(drop=True)
                        y_data = np.hstack((next_y, last_y[::-1]))
                        last_y = next_y
                        # Reverse order of vertical legends to ensure
                        # that the order is consistent with the stack order.
                        self._chart._reverse_vertical_legend = True
                else:
                    y_data = pd.concat(
                        [data[y_column], data[second_y_column][::-1]])

            x_data = pd.concat([data[x_column], data[x_column][::-1]])

            sliced_data = pd.DataFrame({x_column: x_data, y_column: y_data})
            cast_data = self._cast_datetime_axis(sliced_data, x_column)
            source = self._named_column_data_source(
                cast_data, series_name=color_value)

            color_value = str(
                color_value) if color_value is not None else color_value

            if vertical:
                self._chart.figure.patch(
                    x=x_column,
                    y=y_column,
                    alpha=alpha,
                    source=source,
                    legend=color_value,
                    color=color)
            else:
                self._chart.figure.patch(
                    x=y_column,
                    y=x_column,
                    alpha=alpha,
                    source=source,
                    legend=color_value,
                    color=color)

        # Set legend defaults if there are multiple series.
        if color_column is not None:
            self._chart.style._apply_settings('legend')

        return self._chart


class PlotNumericDensityXY(BasePlot):
    """Plot functions for single density:
    Methods:
        - histogram
        - kde
    """

    # def __dir__(self):
    #     """Hide inherited plotting methods"""
    #     inherited_public_methods = [
    #         attr for attr in dir(PlotNumericXY)
    #         if callable(getattr(PlotNumericXY, attr))
    #         and not attr.startswith("_")
    #     ]
    #     return sorted((set(dir(self.__class__)) | set(self.__dict__.keys())) -
    #                   set(inherited_public_methods))

    def histogram(self,
                  data_frame,
                  values_column,
                  color_column=None,
                  color_order=None,
                  method='count',
                  bins='auto'):
        """Histogram.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            values_column (str): Column of numeric values.
            color_column (str, optional): Column name to group by on
                the color dimension.
            color_order (list, optional): List of values within the
                'color_column' for specific sorting of the colors.
            method (str, optional):
            - 'count': Result will contain the number of samples at each bin.
            - 'density': Result is the value of the probability density
                function at each bin.
                The PDF is normalized so that the integral over the range is 1.
            - 'mass': Result is the value of the probability mass
                function at each bin.
                The PMF is normalized so that the value is equivalent to
                the sample count at each bin divided by the total count.
            bins (int or sequence of scalars or str, optional):
                If bins is an int, it defines the number of equal-width
                bins in the given range.
                If bins is a sequence, it defines the bin edges,
                including the rightmost edge, allowing for non-uniform
                bin widths. See numpy.histogram documentation for more details.
            - ‘auto’:
                Maximum of the ‘sturges’ and ‘fd’ estimators.
                Provides good all around performance.
            - ‘fd’ (Freedman Diaconis Estimator)
                Robust (resilient to outliers) estimator that takes into
                account data variability and data size.
            - ‘doane’
                An improved version of Sturges’ estimator that works
                better with non-normal datasets.
            - ‘scott’
                Less robust estimator that that takes into account data
                variability and data size.
            - ‘rice’
                Estimator does not take variability into account, only
                data size. Commonly overestimates number of bins required.
            - ‘sturges’
                R’s default method, only accounts for data size.
                Only optimal for gaussian data and underestimates number
                of bins for large non-gaussian datasets.
            - ‘sqrt’
                Square root (of data size) estimator, used by Excel and
                other programs for its speed and simplicity.
        """
        vertical = self._chart.axes._vertical

        colors, color_values = self._get_color_and_order(
            data_frame, color_column, color_order)

        for color_value, color in zip(color_values, colors):

            if color_column is None:  # Single line
                sliced_data = data_frame[[values_column]]
            else:
                sliced_data = data_frame[data_frame[color_column] ==
                                         color_value][[values_column]]

            density = True if method == 'density' else False
            hist, edges = np.histogram(sliced_data, density=density, bins=bins)

            if method == 'mass':
                hist = hist * 1.0 / hist.sum()

            histogram_data = pd.DataFrame({
                'values': hist,
                'min_edge': edges[:-1],
                'max_edge': edges[1:]
            })

            source = self._named_column_data_source(
                histogram_data, series_name=color_value)

            color_value = str(
                color_value) if color_value is not None else color_value

            if vertical:
                self._chart.figure.quad(
                    top='values',
                    bottom=0,
                    left='min_edge',
                    right='max_edge',
                    source=source,
                    fill_color=color,
                    line_color=color,
                    alpha=.3,
                    legend=color_value)
            else:
                self._chart.figure.quad(
                    top='max_edge',
                    bottom='min_edge',
                    left=0,
                    right='values',
                    source=source,
                    fill_color=color,
                    line_color=color,
                    alpha=.3,
                    legend=color_value)

        # Set legend defaults if there are multiple series.
        if color_column is not None:
            self._chart.style._apply_settings('legend')

        return self._chart

    def kde(self,
            data_frame,
            values_column,
            color_column=None,
            color_order=None):
        """Kernel Density Estimate Plot.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            values_column (str): Column of numeric values.
            color_column (str, optional): Column name to group by on
                the color dimension.
            color_order (list, optional): List of values within the
                'color_column' for specific sorting of the colors.
        """
        # Vertical is unused since the logic is handled
        # by the area chart
        # vertical = self._chart.axes._vertical

        if color_column is not None:
            color_values = sorted(data_frame[color_column].unique())
        else:
            color_values = [None]

        data = pd.DataFrame()
        for color_value in color_values:
            if color_column is None:  # Single line
                sliced_data = data_frame
            else:
                sliced_data = data_frame[data_frame[color_column] ==
                                         color_value]
            values = sliced_data[values_column]

            kde = gaussian_kde(values)
            index = np.linspace(values.min(), values.max(), 300)
            kde_pdf = kde.evaluate(index)
            data = pd.concat(
                [
                    data,
                    pd.DataFrame({
                        'x': index,
                        'y': kde_pdf,
                        'color': color_value
                    })
                ],
                axis=0)

        color_column = 'color' if color_column is not None else None

        PlotNumericXY.area(
            self,
            data,
            'x',
            'y',
            color_column=color_column,
            color_order=color_values,
            stacked=False)

        return self._chart


class PlotDensityXY(BasePlot):
    """Plot functions for denxity X & Y:
    Methods:
        - hexbin
    """

    def hexbin(self,
               data_frame,
               x_values_column,
               y_values_column,
               size,
               color_palette='Blues',
               reverse_color_order=False,
               orientation='pointytop',
               color_value_range=10
               ):
        """Hexbin.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            x_values_column (str): Column of numeric values to bin into tiles.
            y_values_column (str): Column of numeric values to bin into tiles.
            size (float): Bin size for the tiles.
            color_palette (str, chartify.ColorPalette): Color palette to
                apply to the tiles.
                See chartify.color_palettes.show() for available color palettes.
            reverse_color_order (bool): Reverse order of the color palette.
            orientation (str): "pointytop" or "flattop". Whether the hexagonal
                tiles should be oriented with a pointed corner on top, or a
                flat side on top.
            color_value_range (int): The size of the range of colors in
                the color palette.
                A larger color range will result in greater variation
                among the cell colors.
        """
        if isinstance(color_palette, str):
            color_palette = color_palettes[color_palette]
        if reverse_color_order:
            color_palette = color_palette[::-1]
        color_palette = color_palette.expand_palette(color_value_range)
        color_palette = [c.get_hex_l() for c in color_palette.colors]

        # Set the chart aspect ratio otherwise the hexbins won't be symmetric.
        aspect_scale = (self._chart.style.plot_width
                        / self._chart.style.plot_height)
        self._chart.figure.match_aspect = True
        self._chart.figure.aspect_scale = aspect_scale
        self._chart.figure.hexbin(
            data_frame[x_values_column],
            data_frame[y_values_column],
            size=size,
            orientation=orientation,
            aspect_scale=aspect_scale,
            palette=color_palette,
            line_color='white'
            )

        return self._chart


class PlotMixedTypeXY(BasePlot):
    """Plot functions for mixed type x & y axes:
    Methods:
        - bar
        - bar_stacked
        - lollipop
        - parallel
    """

    def _set_categorical_axis_default_factors(self, vertical, factors):
        """Reassign the categorical axis with the given factors.
        """
        if vertical:
            self._chart.figure.x_range.factors = factors
        else:
            self._chart.figure.y_range.factors = factors

    def _set_categorical_axis_default_range(self, vertical, data_frame,
                                            numeric_column):
        """Set numeric axis range based on the input data.
        """
        max_value = data_frame[numeric_column].max()
        min_value = data_frame[numeric_column].min()

        max_ge_zero = max_value >= 0
        min_ge_zero = min_value >= 0

        range_start, range_end = None, None
        if max_ge_zero and min_ge_zero:
            range_start = 0
        elif not max_ge_zero and not min_ge_zero:
            range_end = 0

        max_value = max(max_value, 0)
        min_value = min(min_value, 0)

        if vertical:
            self._chart.axes.set_yaxis_range(start=range_start, end=range_end)
            self._chart.axes.set_yaxis_tick_format(
                self._axis_format_precision(max_value, min_value))
        else:
            self._chart.axes.set_xaxis_range(start=range_start, end=range_end)
            self._chart.axes.set_xaxis_tick_format(
                self._axis_format_precision(max_value, min_value))

    @staticmethod
    def _get_bar_width(factors):
        """Get the bar width based on the number of factors"""
        n_factors = len(factors)
        if n_factors == 1:
            return .3
        elif n_factors == 2:
            return .5
        elif n_factors == 3:
            return .7
        else:
            return .9

    def _construct_source(self,
                          data_frame,
                          categorical_columns,
                          numeric_column,
                          stack_column=None,
                          normalize=False,
                          categorical_order_by=None,
                          categorical_order_ascending=False):
        """Constructs ColumnDataSource
        Returns:
            source: ColumnDataSource
            factors: list of categorical factors
            stack_values: list of stack values
        """
        # Cast categorical columns to a list.
        if not isinstance(categorical_columns, str):
            categorical_columns = [c for c in categorical_columns]
        else:
            categorical_columns = [categorical_columns]

        # Check that there's only one row per grouping
        grouping = categorical_columns[:]
        if stack_column is not None:
            grouping.append(stack_column)
        rows_per_grouping = (data_frame.groupby(grouping).size())
        max_one_row_per_grouping = all(rows_per_grouping <= 1)
        if not max_one_row_per_grouping:
            raise ValueError(
                """Each categorical grouping should have at most 1 observation.
                Group the dataframe and aggregate before passing to
                the plot function.
                """)

        # Cast stack column to strings
        # Plotting functions will break with non-str types.
        type_map = {}
        if stack_column is not None:
            type_map[stack_column] = str
        # Apply mapping within pivot so original data frame isn't modified.
        source = (
            pd.pivot_table(
                data_frame.astype(type_map),
                columns=stack_column,
                index=categorical_columns,
                values=numeric_column,
                aggfunc='sum').fillna(0)  # NA columns break the stacks
        )

        # Normalize values at the grouped levels.
        # Only relevant for stacked objects
        if normalize:
            source = source.div(source.sum(axis=1), axis=0)

        order_length = getattr(categorical_order_by, "__len__", None)
        # Sort the categories
        if categorical_order_by == 'values':
            # Recursively sort values within each level of the index.
            row_totals = source.sum(axis=1)
            row_totals.name = 'sum'
            old_index = row_totals.index
            row_totals = row_totals.reset_index()
            row_totals.columns = ['_%s' % col for col in row_totals.columns]
            row_totals.index = old_index

            heirarchical_sort_cols = categorical_columns[:]
            for i, _ in enumerate(heirarchical_sort_cols):
                row_totals['level_%s' % i] = (row_totals.groupby(
                    heirarchical_sort_cols[:i + 1])['_sum'].transform('sum'))
            row_totals = row_totals.sort_values(
                by=[
                    'level_%s' % i
                    for i, _ in enumerate(heirarchical_sort_cols)
                ],
                ascending=categorical_order_ascending)
            source = source.reindex(row_totals.index)
        elif categorical_order_by == 'labels':
            source = source.sort_index(
                0, ascending=categorical_order_ascending)
        # Manual sort
        elif order_length is not None:
            source = source.reindex(categorical_order_by, axis='index')
        else:
            raise ValueError(
                """Must be 'values', 'labels', or a list of values.""")

        # Cast all categorical columns to strings
        # Plotting functions will break with non-str types.
        if isinstance(source.index, pd.MultiIndex):
            for level in range(len(source.index.levels)):
                source.index = source.index.set_levels(
                    source.index.levels[level].astype(str), level=level)
        else:
            source.index = source.index.astype(str)

        factors = source.index
        source = source.reset_index(drop=True)
        stack_values = source.columns
        source = self._named_column_data_source(source, series_name=None)
        source.add(factors, 'factors')

        return source, factors, stack_values

    def text(self,
             data_frame,
             categorical_columns,
             numeric_column,
             text_column,
             color_column=None,
             color_order=None,
             categorical_order_by='values',
             categorical_order_ascending=False,
             font_size='1em',
             x_offset=0,
             y_offset=0,
             angle=0,
             text_color=None):
        """Text plot.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            categorical_columns (str or list): Column name to plot on
                the categorical axis.
            numeric_column (str): Column name to plot on the numerical axis.
            text_column (str): Column name to plot as text labels.
            color_column (str, optional): Column name to group by on the
                color dimension.
            color_order (list, optional): List of values within the
                'color_column' for specific color sort.
            categorical_order_by (str or array-like, optional):
                Dimension for ordering the categorical axis. Default 'values'.
                - 'values': Order categorical axis by the numerical axis
                    values. Default.
                - 'labels': Order categorical axis by the categorical labels.
                - array-like object (list, tuple, np.array): New labels
                    to conform the categorical axis to.
            categorical_order_ascending (bool, optional): Sort order of the
                categorical axis. Default False.
            font_size (str, optional): Size of text.
            x_offset (int, optional): # of pixels for horizontal text offset.
                Can be negative. Default: 0.
            y_offset (int, optional): # of pixels for vertical text offset.
                Can be negative. Default: 0.
            angle (int): Degrees from horizontal for text rotation.
            text_color (str): Color name or hex value.
                See chartify.color_palettes.show() for available color names.
                If omitted, will default to the next color in
                the current color palette.
        """
        vertical = self._chart.axes._vertical
        text_font = self._chart.style._get_settings('text_callout_and_plot')[
            'font']

        source, factors, _ = self._construct_source(
            data_frame,
            categorical_columns,
            numeric_column,
            categorical_order_by=categorical_order_by,
            categorical_order_ascending=categorical_order_ascending)

        if text_color:
            text_color = Color(text_color).get_hex_l()
            colors, color_values = [text_color], [None]
        else:
            colors, color_values = self._get_color_and_order(
                data_frame, color_column, color_order)

        self._set_categorical_axis_default_factors(vertical, factors)

        if vertical:
            text_align = 'center'
            text_baseline = 'bottom'
            x_value, y_value = 'factors', numeric_column
            y_offset = y_offset - 4
        else:
            y_value, x_value = 'factors', numeric_column
            text_align = 'left'
            text_baseline = 'middle'
            x_offset = x_offset + 10

        for color_value, color in zip(color_values, colors):

            if color_column is None:  # Single series
                sliced_data = data_frame
            else:
                sliced_data = data_frame[data_frame[color_column] ==
                                         color_value]

            # Construct a new source based on the sliced data.
            source, _, _ = self._construct_source(
                sliced_data,
                categorical_columns,
                numeric_column,
                categorical_order_by=categorical_order_by,
                categorical_order_ascending=categorical_order_ascending)
            sliced_data = (sliced_data.set_index(categorical_columns)
                           .reindex(source.data['factors']).reset_index())
            # Text column isn't in the source so it needs to be added.
            if text_column != numeric_column:
                source.add(sliced_data[text_column], name=text_column)

            self._chart.figure.text(
                text=text_column,
                x=x_value,
                y=y_value,
                text_font_size=font_size,
                source=source,
                text_color=color,
                y_offset=y_offset,
                x_offset=x_offset,
                angle=angle,
                angle_units='deg',
                text_align=text_align,
                text_baseline=text_baseline,
                text_font=text_font)

        return self._chart

    def text_stacked(self,
                     data_frame,
                     categorical_columns,
                     numeric_column,
                     stack_column,
                     text_column,
                     normalize=False,
                     stack_order=None,
                     categorical_order_by='values',
                     categorical_order_ascending=False,
                     font_size='1em',
                     x_offset=0,
                     y_offset=0,
                     angle=0,
                     text_color=None):
        """Text plot for use with stacked plots.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            categorical_columns (str or list): Column name to plot on
                the categorical axis.
            numeric_column (str): Column name to plot on the numerical axis.
            text_column (str): Column name to plot as text labels.
                Note: Null text values will be omitted from the plot.
            stack_column (str): Column name to group by on the stack dimension.
            normalize (bool, optional): Normalize numeric dimension for
                100% stacked bars. Default False.
            stack_order (list, optional): List of values within the
                'stack_column' dimension for specific stack sort.
            categorical_order_by (str or array-like, optional):
                Dimension for ordering the categorical axis. Default 'values'.
                - 'values': Order categorical axis by the numerical
                    axis values. Default.
                - 'labels': Order categorical axis by the categorical labels.
                - array-like object (list, tuple, np.array): New labels
                    to conform the categorical axis to.
            categorical_order_ascending (bool, optional): Sort order of the
                categorical axis. Default False.
            font_size (str, optional): Size of text.
            x_offset (int, optional): # of pixels for horizontal text offset.
                Can be negative. Default: 0.
            y_offset (int, optional): # of pixels for vertical text offset.
                Can be negative. Default: 0.
            angle (int): Degrees from horizontal for text rotation.
            text_color (str): Color name or hex value.
                See chartify.color_palettes.show() for available color names.
                If omitted, will default to the next color in
                the current color palette.
        """
        vertical = self._chart.axes._vertical
        text_font = self._chart.style._get_settings('text_callout_and_plot')[
            'font']

        source, factors, stack_values = self._construct_source(
            data_frame,
            categorical_columns,
            numeric_column,
            stack_column,
            normalize=normalize,
            categorical_order_by=categorical_order_by,
            categorical_order_ascending=categorical_order_ascending)

        if text_color:
            text_color = Color(text_color).get_hex_l()
            if stack_order is None:
                stack_order = sorted(data_frame[stack_column].unique())
            else:
                # If stack order is set then
                # make sure it includes all the levels.
                if not set(data_frame[stack_column].unique()).issubset(
                        set(stack_order)):
                    raise ValueError("""Color order must include
                                    all unique factors of variable `%s`.""" %
                                     stack_order)
            colors, color_values = [text_color] * len(
                data_frame[stack_column].unique()), stack_order
        else:
            colors, color_values = self._get_color_and_order(
                data_frame, stack_column, stack_order)

        self._set_categorical_axis_default_factors(vertical, factors)
        self._set_categorical_axis_default_range(vertical, data_frame,
                                                 numeric_column)

        # Set numeric axis format to percentages.
        if normalize:
            if vertical:
                self._chart.axes.set_yaxis_tick_format("0%")
            else:
                self._chart.axes.set_xaxis_tick_format("0%")

        text_baseline = 'middle'
        if vertical:
            text_align = 'center'
        else:
            text_align = 'left'
            x_offset = x_offset + 10

        cumulative_numeric_value = None

        for color_value, color in zip(color_values, colors):

            sliced_data = data_frame[(data_frame[stack_column] == color_value)]
            # Reindex to be consistent with the factors.
            type_map = {column: str for column in categorical_columns}
            sliced_data = (sliced_data.astype(type_map)
                           .set_index(categorical_columns)
                           .reindex(index=factors).reset_index())

            text_values = np.where(sliced_data[text_column].isna(), '',
                                   sliced_data[text_column])

            if cumulative_numeric_value is not None:
                cumulative_numeric_value = (
                    cumulative_numeric_value
                    + source.data[color_value]
                    * .5
                    )
            else:
                cumulative_numeric_value = source.data[color_value] * .5

            if vertical:
                x_value, y_value = factors, cumulative_numeric_value
            else:
                y_value, x_value = factors, cumulative_numeric_value

            self._chart.figure.text(
                text=text_values,
                x=x_value,
                y=y_value,
                text_font_size=font_size,
                text_color=color,
                y_offset=y_offset,
                x_offset=x_offset,
                angle=angle,
                angle_units='deg',
                text_align=text_align,
                text_baseline=text_baseline,
                text_font=text_font)

            cumulative_numeric_value = (
                cumulative_numeric_value
                + source.data[color_value]
                * .5
            )

        return self._chart

    def bar(self,
            data_frame,
            categorical_columns,
            numeric_column,
            color_column=None,
            color_order=None,
            categorical_order_by='values',
            categorical_order_ascending=False):
        """Bar chart.
        Note:
            To change the orientation set x_axis_type or y_axis_type
            argument of the Chart object.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            categorical_columns (str or list): Column name to plot on
                the categorical axis.
            numeric_column (str): Column name to plot on the numerical axis.
            color_column (str, optional): Column name to group by on
                the color dimension.
            color_order (list, optional): List of values within the
                'color_column' for specific color sort.
            categorical_order_by (str or array-like, optional):
                Dimension for ordering the categorical axis. Default 'values'.
                - 'values': Order categorical axis by the numerical
                    axis values. Default.
                - 'labels': Order categorical axis by the categorical labels.
                - array-like object (list, tuple, np.array): New labels
                    to conform the categorical axis to.
            categorical_order_ascending (bool, optional): Sort order of the
                categorical axis. Default False.
        """
        vertical = self._chart.axes._vertical

        source, factors, _ = self._construct_source(
            data_frame,
            categorical_columns,
            numeric_column,
            categorical_order_by=categorical_order_by,
            categorical_order_ascending=categorical_order_ascending)

        colors, _ = self._get_color_and_order(data_frame, color_column,
                                              color_order, categorical_columns)
        if color_column is None:
            colors = colors[0]

        self._set_categorical_axis_default_factors(vertical, factors)
        self._set_categorical_axis_default_range(vertical, data_frame,
                                                 numeric_column)
        bar_width = self._get_bar_width(factors)
        if vertical:
            self._chart.figure.vbar(
                x='factors',
                width=bar_width,
                top=numeric_column,
                bottom=0,
                line_color='white',
                source=source,
                fill_color=colors)
        else:
            self._chart.figure.hbar(
                y='factors',
                height=bar_width,
                right=numeric_column,
                left=0,
                line_color='white',
                source=source,
                fill_color=colors)
        return self._chart

    def interval(self,
                 data_frame,
                 categorical_columns,
                 lower_bound_column,
                 upper_bound_column,
                 middle_column=None,
                 categorical_order_by='values',
                 categorical_order_ascending=False,
                 color='black'):
        """Interval.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            categorical_columns (str or list): Column name to plot on
                the categorical axis.
            lower_bound_column (str): Column name to plot on the
                numerical axis for the lower bound.
            upper_bound_column (str): Column name to plot on the
                numerical axis for the upper bound.
            middle_column (str, optional): Column name to plot on the
                numerical axis for the middle tick.
            categorical_order_by (str or array-like, optional):
                Dimension for ordering the categorical axis. Default 'values'.
                - 'values': Order categorical axis by the numerical
                    axis values. Default.
                - 'labels': Order categorical axis by the categorical labels.
                - array-like object (list, tuple, np.array): New labels
                    to conform the categorical axis to.
            categorical_order_ascending (bool, optional): Sort order of the
                categorical axis. Default False.
            color (str): Color name or hex value.
                See chartify.color_palettes.show() for available color names.
        """
        interval_color = Color(color).get_hex_l()

        vertical = self._chart.axes._vertical

        _, factors, _ = self._construct_source(
            data_frame,
            categorical_columns,
            lower_bound_column,
            categorical_order_by=categorical_order_by,
            categorical_order_ascending=categorical_order_ascending)
        self._set_categorical_axis_default_factors(vertical, factors)

        # Set the axis precision
        max_value = max(data_frame[lower_bound_column].max(),
                        data_frame[upper_bound_column].max())
        min_value = min(data_frame[lower_bound_column].min(),
                        data_frame[upper_bound_column].min())
        max_value, min_value = max(max_value, 0), min(min_value, 0)
        if vertical:
            self._chart.axes.set_yaxis_tick_format(
                self._axis_format_precision(max_value,
                                            min_value)
                )
        else:
            self._chart.axes.set_xaxis_tick_format(
                self._axis_format_precision(max_value,
                                            min_value)
                )

        interval_settings = self._chart.style._get_settings('interval_plot')
        SPACE_BETWEEN_BARS = interval_settings['space_between_bars']
        MARGIN = interval_settings['margin']
        BAR_WIDTH = interval_settings['bar_width']
        SPACE_BETWEEN_CATEGORIES = interval_settings[
            'space_between_categories']
        INTERVAL_END_STEM_SIZE = interval_settings['interval_end_stem_size']
        INTERVAL_MIDPOINT_STEM_SIZE = interval_settings[
            'interval_midpoint_stem_size']

        def bar_edges(index, category_number):
            """Return start, midpoint, end edge coordinates"""
            bar_num = index + 1
            start = (
                bar_num * MARGIN + (bar_num - 1) * MARGIN + (bar_num - 1) *
                (BAR_WIDTH) + SPACE_BETWEEN_BARS * (bar_num - 1) +
                SPACE_BETWEEN_CATEGORIES * (category_number - 1))
            midpoint = start + BAR_WIDTH / 2.
            end = start + BAR_WIDTH
            return (start, midpoint, end)

        aggregate_columns = [lower_bound_column, upper_bound_column]
        if middle_column is not None:
            aggregate_columns.append(middle_column)
        # Categorical_columns to List
        if not isinstance(categorical_columns, str):
            categorical_columns = [c for c in categorical_columns]
        else:
            categorical_columns = [categorical_columns]
        # Cast categorical columns to str to prevent dates from breaking
        type_map = {column: str for column in categorical_columns}
        values = (data_frame.astype(type_map)
                  .groupby(categorical_columns)[aggregate_columns].sum()
                  .reindex(factors).reset_index())
        # Need to keep track of changes to categorical columns
        # To calculate spacing between values
        values['new_heirarchy'] = False
        if len(categorical_columns) > 1:
            for col in categorical_columns[:-1]:
                values['new_column'] = values[col] != values[col].shift(1)
                values['new_heirarchy'] = values[[
                    'new_heirarchy', 'new_column'
                ]].max(axis=1)
            values['category_number'] = values['new_heirarchy'].cumsum()
        else:
            values['category_number'] = 1
        for index, row in values.iterrows():
            bar_midpoint = bar_edges(index, row['category_number'])[1]
            if vertical:
                # Vertical line
                self._chart.figure.segment(
                    bar_midpoint,
                    row[lower_bound_column],
                    bar_midpoint,
                    row[upper_bound_column],
                    color=interval_color)
                # Top
                self._chart.figure.segment(
                    bar_midpoint - INTERVAL_END_STEM_SIZE,
                    row[upper_bound_column],
                    bar_midpoint + INTERVAL_END_STEM_SIZE,
                    row[upper_bound_column],
                    color=interval_color)
                # Bottom
                self._chart.figure.segment(
                    bar_midpoint - INTERVAL_END_STEM_SIZE,
                    row[lower_bound_column],
                    bar_midpoint + INTERVAL_END_STEM_SIZE,
                    row[lower_bound_column],
                    color=interval_color)
                # Middle
                if middle_column is not None:
                    self._chart.figure.segment(
                        bar_midpoint - INTERVAL_MIDPOINT_STEM_SIZE,
                        row[middle_column],
                        bar_midpoint + INTERVAL_MIDPOINT_STEM_SIZE,
                        row[middle_column],
                        color=interval_color)
            else:
                # Horizontal line
                self._chart.figure.segment(
                    row[lower_bound_column],
                    bar_midpoint,
                    row[upper_bound_column],
                    bar_midpoint,
                    color=interval_color)
                # Left
                self._chart.figure.segment(
                    row[lower_bound_column],
                    bar_midpoint - INTERVAL_END_STEM_SIZE,
                    row[lower_bound_column],
                    bar_midpoint + INTERVAL_END_STEM_SIZE,
                    color=interval_color)
                # Right
                self._chart.figure.segment(
                    row[upper_bound_column],
                    bar_midpoint - INTERVAL_END_STEM_SIZE,
                    row[upper_bound_column],
                    bar_midpoint + INTERVAL_END_STEM_SIZE,
                    color=interval_color)
                # Middle
                if middle_column is not None:
                    self._chart.figure.segment(
                        row[middle_column],
                        bar_midpoint - INTERVAL_MIDPOINT_STEM_SIZE,
                        row[middle_column],
                        bar_midpoint + INTERVAL_MIDPOINT_STEM_SIZE,
                        color=interval_color)
        return self._chart

    def bar_stacked(self,
                    data_frame,
                    categorical_columns,
                    numeric_column,
                    stack_column,
                    normalize=False,
                    stack_order=None,
                    categorical_order_by='values',
                    categorical_order_ascending=False):
        """Plot stacked bar chart.
        Note:
            - To change the orientation set x_axis_type or y_axis_type
            argument of the Chart object.
            - Stacked numeric values must be all positive or all negative.
            To plot both positive and negative values on the same chart
            call this method twice. Once for the positive values and
            once for the negative values.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            categorical_columns (str or list): Column name to plot on
                the categorical axis.
            numeric_column (str): Column name to plot on the numerical axis.
            stack_column (str): Column name to group by on the stack dimension.
            normalize (bool, optional): Normalize numeric dimension for
                100% stacked bars. Default False.
            stack_order (list, optional): List of values within the
                'stack_column' dimension for specific stack sort.
            categorical_order_by (str or array-like, optional):
                Dimension for ordering the categorical axis. Default 'values'.
                - 'values': Order categorical axis by the numerical
                    axis values. Default.
                - 'labels': Order categorical axis by the categorical labels.
                - array-like object (list, tuple, np.array): New labels
                    to conform the categorical axis to.
            categorical_order_ascending (bool, optional): Sort order
                of the categorical axis. Default False.
        """

        vertical = self._chart.axes._vertical

        source, factors, stack_values = self._construct_source(
            data_frame,
            categorical_columns,
            numeric_column,
            stack_column,
            normalize=normalize,
            categorical_order_by=categorical_order_by,
            categorical_order_ascending=categorical_order_ascending)

        colors, _ = self._get_color_and_order(data_frame, stack_column,
                                              stack_order)
        if stack_column is None:
            colors = colors[0]

        self._set_categorical_axis_default_factors(vertical, factors)
        self._set_categorical_axis_default_range(vertical, data_frame,
                                                 numeric_column)
        bar_width = self._get_bar_width(factors)
        # Set numeric axis format to percentages.
        if normalize:
            if vertical:
                self._chart.axes.set_yaxis_tick_format("0%")
            else:
                self._chart.axes.set_xaxis_tick_format("0%")

        if stack_order is not None:
            if not set(stack_values).issubset(set(stack_order)):
                raise ValueError("""Stack order must include all distinct
                                    values of the stack column `%s`
                                 """ % (stack_column))
            stack_values = stack_order

        legend = [bokeh.core.properties.value(str(x)) for x in stack_values]

        if vertical:
            self._chart.figure.vbar_stack(
                stack_values,
                x='factors',
                width=bar_width,
                line_color='white',
                source=source,
                fill_color=colors,
                legend=legend)
        else:
            self._chart.figure.hbar_stack(
                stack_values,
                y='factors',
                height=bar_width,
                line_color='white',
                source=source,
                fill_color=colors,
                legend=legend)
        self._chart.style._apply_settings('legend')
        # Reverse order of vertical legends to ensure that the order
        # is consistent with the stack order.
        self._chart._reverse_vertical_legend = True

        return self._chart

    def lollipop(self,
                 data_frame,
                 categorical_columns,
                 numeric_column,
                 color_column=None,
                 color_order=None,
                 categorical_order_by='values',
                 categorical_order_ascending=False):
        """Lollipop chart.
        Note:
            To change the orientation set x_axis_type or y_axis_type
            argument of the Chart object.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            categorical_columns (str or list): Column name to plot on
                the categorical axis.
            numeric_column (str): Column name to plot on the numerical axis.
            color_column (str, optional): Column name to group by on
                the color dimension.
            color_order (list, optional):
                List of values within the 'color_column' for
                    specific color sort.
            categorical_order_by (str or array-like, optional):
                Dimension for ordering the categorical axis. Default 'values'.
                - 'values': Order categorical axis by the numerical axis values.
                - 'labels': Order categorical axis by the categorical labels.
                - array-like object (list, tuple, np.array): New labels
                    to conform the categorical axis to.
            categorical_order_ascending (bool, optional):
                Sort order of the categorical axis. Default False.
        """

        vertical = self._chart.axes._vertical

        source, factors, _ = self._construct_source(
            data_frame,
            categorical_columns,
            numeric_column,
            categorical_order_by=categorical_order_by,
            categorical_order_ascending=categorical_order_ascending)

        colors, _ = self._get_color_and_order(data_frame, color_column,
                                              color_order, categorical_columns)
        if color_column is None:
            colors = colors[0]

        self._set_categorical_axis_default_factors(vertical, factors)
        self._set_categorical_axis_default_range(vertical, data_frame,
                                                 numeric_column)

        if vertical:
            self._chart.figure.segment(
                'factors',
                0,
                'factors',
                numeric_column,
                line_width=2,
                line_color=colors,
                source=source)
            self._chart.figure.circle(
                'factors',
                numeric_column,
                size=10,
                fill_color=colors,
                line_color=colors,
                line_width=3,
                source=source)
        else:
            self._chart.figure.segment(
                0,
                'factors',
                numeric_column,
                'factors',
                line_width=2,
                line_color=colors,
                source=source)
            self._chart.figure.circle(
                numeric_column,
                'factors',
                size=10,
                fill_color=colors,
                line_color=colors,
                line_width=3,
                source=source)
        return self._chart

    def parallel(self,
                 data_frame,
                 categorical_columns,
                 numeric_column,
                 color_column=None,
                 color_order=None,
                 categorical_order_by='values',
                 categorical_order_ascending=False,
                 line_dash='solid',
                 line_width=4,
                 alpha=1.0
                 ):
        """Parallel coordinate plot.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            categorical_columns (str or list): Column name to plot on
                the categorical axis.
            numeric_column (str): Column name to plot on the numerical axis.
            color_column (str, optional): Column name to group by on
                the color dimension.
            color_order (list, optional): List of values within the
                'color_column' for specific color sort.
            categorical_order_by (str or array-like, optional):
                Dimension for ordering the categorical axis. Default 'values'.
                - 'values': Order categorical axis by the numerical axis values.
                - 'labels': Order categorical axis by the categorical labels.
                - array-like object (list, tuple, np.array): New labels
                    to conform the categorical axis to.
            categorical_order_ascending (bool, optional):
                Sort order of the categorical axis. Default False.
            line_dash (str, optional): Dash style for the line. One of:
                - 'solid'
                - 'dashed'
                - 'dotted'
                - 'dotdash'
                - 'dashdot'
            line_width (int, optional): Width of the line
            alpha (float): Alpha value
        """
        settings = self._chart.style._get_settings('line_plot')
        line_cap = settings['line_cap']
        line_join = settings['line_join']

        vertical = self._chart.axes._vertical

        source, factors, _ = self._construct_source(
            data_frame,
            categorical_columns,
            numeric_column,
            # Each color has its own stack for parallel plots.
            # This causes each color to appear as its own column.
            stack_column=color_column,
            categorical_order_by=categorical_order_by,
            categorical_order_ascending=categorical_order_ascending)

        colors, color_values = self._get_color_and_order(
            data_frame, color_column, color_order)

        self._set_categorical_axis_default_factors(vertical, factors)
        self._set_numeric_axis_default_format(data_frame,
                                              numeric_column,
                                              numeric_column)

        for color_value, color in zip(color_values, colors):

            if color_column is None:  # Single series
                color_value = numeric_column
                legend = None
            else:
                legend = bokeh.core.properties.value(str(color_value))

            if vertical:
                x_value, y_value = 'factors', str(color_value)
            else:
                y_value, x_value = 'factors', str(color_value)

            self._chart.figure.line(
                x=x_value,
                y=y_value,
                source=source,
                line_width=line_width,
                color=color,
                line_join=line_join,
                line_cap=line_cap,
                legend=legend,
                line_dash=line_dash,
                alpha=alpha)

        # Set legend defaults if there are multiple series.
        if color_column is not None:
            self._chart.style._apply_settings('legend')

    def scatter(self,
                data_frame,
                categorical_columns,
                numeric_column,
                size_column=None,
                color_column=None,
                color_order=None,
                categorical_order_by='count',
                categorical_order_ascending=False,
                alpha=1.0,
                marker='circle'):
        """Scatter chart.
        Note:
            To change the orientation set x_axis_type or y_axis_type
            argument of the Chart object.
        Args:
            data_frame (pandas.DataFrame): Data source for the plot.
            categorical_columns (str or list): Column name to plot on
                the categorical axis.
            numeric_column (str): Column name to plot on the numerical axis.
            size_column (str, optional): Column name of numerical values
                to plot on the size dimension.
            color_column (str, optional): Column name to group by on
                the color dimension.
            color_order (list, optional):
                List of values within the 'color_column' for
                    specific color sort.
            categorical_order_by (str or array-like, optional):
                Dimension for ordering the categorical axis. Default 'count'.
                - 'count': Order categorical axis by the count of values.
                - 'labels': Order categorical axis by the categorical labels.
                - array-like object (list, tuple, np.array): New labels
                    to conform the categorical axis to.
            categorical_order_ascending (bool, optional):
                Sort order of the categorical axis. Default False.
            alpha (float): Alpha value.
            marker (str): marker type. Valid types:
                'asterisk', 'circle', 'circle_cross', 'circle_x', 'cross',
                'diamond', 'diamond_cross', 'hex', 'inverted_triangle',
                'square', 'square_x', 'square_cross', 'triangle',
                'x', '*', '+', 'o', 'ox', 'o+'
        """
        vertical = self._chart.axes._vertical

        if size_column is None:
            size_column = 15

        axis_factors = data_frame.groupby(categorical_columns).size()

        order_length = getattr(categorical_order_by, "__len__", None)
        if categorical_order_by == 'labels':
            axis_factors = axis_factors.sort_index(
                ascending=categorical_order_ascending).index
        elif categorical_order_by == 'count':
            axis_factors = axis_factors.sort_values(
                ascending=categorical_order_ascending).index
        # User-specified order.
        elif order_length is not None:
            axis_factors = categorical_order_by
        else:
            raise ValueError(
                """Must be 'count', 'labels', or a list of values.""")

        colors, color_values = self._get_color_and_order(
            data_frame, color_column, color_order)
        # Apply factors to the axis.
        self._set_categorical_axis_default_factors(vertical, axis_factors)

        for color_value, color in zip(color_values, colors):
            if color_column is None:  # Single series
                color_value = numeric_column
                legend = None
                sliced_data = data_frame
            else:
                legend = bokeh.core.properties.value(str(color_value))
                sliced_data = data_frame[data_frame[color_column] ==
                                         color_value]
            # Filter to only relevant columns.
            data_factors = sliced_data.set_index(categorical_columns).index
            sliced_data = (
                sliced_data[
                    [col for col in sliced_data.columns
                        if col in (
                            numeric_column, size_column)]])
            source = self._named_column_data_source(
                sliced_data, series_name=color_value)
            source.add(data_factors, 'factors')

            if vertical:
                x_value, y_value = 'factors', numeric_column
            else:
                y_value, x_value = 'factors', numeric_column

            self._chart.figure.scatter(
                x=x_value,
                y=y_value,
                size=size_column,
                fill_color=color,
                line_color=color,
                source=source,
                legend=legend,
                marker=marker,
                alpha=alpha
                )

        # Set legend defaults if there are multiple series.
        if color_column is not None:
            self._chart.style._apply_settings('legend')

        return self._chart

from itertools import cycle
import yaml

import bokeh

from chartify._core import colors
from chartify._core.options import options


class BasePalette:
    """Base class for color palettes."""

    def __init__(self, chart, palette):
        self._chart = chart
        self._set_palette_colors(palette)

    def _set_palette_colors(self, palette):

        try:
            # Palette is a string.
            # Retreive the appropriate ColorPalette object.
            if palette.lower():
                palette = colors.color_palettes[palette]
        except AttributeError:
            pass

        palette_colors = getattr(palette, 'colors', None)
        if palette_colors is not None:
            # Palette is a ColorPalette object
            self._colors = [color.get_hex_l() for color in palette_colors]
        else:
            # Palette is a list of color strings
            self._colors = [
                colors.Color(color).get_hex_l() for color in palette
            ]

    @classmethod
    def _get_palette_class(cls,
                           chart,
                           palette_type='categorical',
                           palette=None,
                           accent_values=None):
        if palette_type == 'categorical':
            if palette is None:
                palette_name = options.get_option(
                    'style.color_palette_categorical')
                palette = colors.color_palettes[palette_name]
            return CategoricalPalette(chart, palette)
        elif palette_type == 'sequential':
            if palette is None:
                palette_name = options.get_option(
                    'style.color_palette_sequential')
                palette = colors.color_palettes[palette_name]
            return OrdinalPalette(chart, palette)
        elif palette_type == 'diverging':
            if palette is None:
                palette_name = options.get_option(
                    'style.color_palette_diverging')
                palette = colors.color_palettes[palette_name]
            return OrdinalPalette(chart, palette)
        elif palette_type == 'accent':
            if palette is None:
                palette_name = options.get_option('style.color_palette_accent')
                palette = colors.color_palettes[palette_name]
            return AccentPalette(chart, palette, accent_values)
        else:
            raise ValueError(
                """Type must be one of: ('categorical', 'sequential',
                                         'diverging', 'accent').""")

    def next_colors(self, color_column_values):
        """Return a list of colors associated with each value."""
        return [self.next_color(o) for o in color_column_values]

    def next_color(self, color_column_value=None):
        """Return the next color from the color palette."""
        raise NotImplementedError


class OrderedPaletteMixin:
    """Mixin for palettes that should be applied in order."""

    def reset_palette_order(self):
        """Reset the order of the color palette."""
        self._color_cycle = cycle(self._colors)

    def next_color(self, color_column_value=None):
        """Return the next color from the color palette."""
        return next(self._color_cycle)


class CategoricalPalette(OrderedPaletteMixin, BasePalette):
    """Categorical palettes are those that have no designated order."""

    def __init__(self, chart, palette):
        super(CategoricalPalette, self).__init__(chart, palette)
        self._color_cycle = cycle(self._colors)


class OrdinalPalette(OrderedPaletteMixin, BasePalette):
    """Ordinal palettes have an order associated with the color dimension."""

    def __init__(self, chart, palette):
        super(OrdinalPalette, self).__init__(chart, palette)
        self._color_cycle = cycle(self._colors)

    def next_colors(self, color_column_values):
        """Return a list of colors associated with each value."""
        palette_colors = self._colors
        if len(color_column_values) > len(self._colors):
            palette = (colors.ColorPalette.from_hex_list(colors=self._colors)
                       .expand_palette(len(color_column_values)))
            palette_colors = [color.get_hex_l() for color in palette.colors]
        return bokeh.palettes.linear_palette(palette_colors,
                                             len(color_column_values))


class AccentPalette(BasePalette):
    """Accent Palette.
    Accent palette assigns specific colors to specific values
    within the color dimension.
    The default color is used for values that are unassigned."""

    def __init__(self, chart, palette, accent_values=None):
        super(AccentPalette, self).__init__(chart, palette)
        self._accent_color_map = None
        self.set_accent_values(accent_values)
        self.set_default_color(
            options.get_option('style.color_palette_accent_default_color'))

    def set_accent_values(self, accent_values):
        """Set values that should be accented.
        Args:
        - accent_values (list or dict): List of values that
        should be accented or dictionary of 'value': 'color' pairs.
        """
        if isinstance(accent_values, dict):
            self._accent_color_map = {
                value: colors.Color(color).get_hex_l()
                for value, color in accent_values.items()
            }
        else:
            self._accent_color_map = dict(
                list(zip(accent_values, cycle(self._colors))))
        return self._chart

    def next_color(self, color_column_value=None):
        """Return the color for the given values.
        Args:
            color_column_value: TODO
        """
        return self._accent_color_map.get(color_column_value,
                                          self._default_color)

    def set_default_color(self, color):
        """
        Set default color of values in the 'color_column'
        that are not accented."""
        color = colors.Color(color).get_hex_l()
        self._default_color = color


class Style:
    """
    Contains attributes and methods for modifying the aesthetic
    style of the chart.
    """

    def __init__(self, chart, layout):
        self._chart = chart
        self.color_palette = BasePalette._get_palette_class(self._chart)
        self._layout = layout
        self._set_width_and_height(layout)

        self.settings = {
            'legend': {
                'figure.legend.orientation': 'horizontal',
                'figure.legend.location': 'top_left',
                'figure.legend.label_text_font': 'helvetica'
            },
            'chart': {
                'figure.background_fill_color': "white",
                'figure.xgrid.grid_line_color': None,
                'figure.ygrid.grid_line_color': None,
                'figure.border_fill_color': "white",
                'figure.min_border_left': 60,
                'figure.min_border_right': 60,
                'figure.min_border_top': 40,
                'figure.min_border_bottom': 60,
                'figure.xaxis.axis_line_width': 1,
                'figure.yaxis.axis_line_width': 1,
                'figure.yaxis.axis_line_color': "#C0C0C0",
                'figure.xaxis.axis_line_color': "#C0C0C0",
                'figure.yaxis.axis_label_text_color': "#666666",
                'figure.xaxis.axis_label_text_color': "#666666",
                'figure.xaxis.major_tick_line_color': "#C0C0C0",
                'figure.xaxis.minor_tick_line_color': "#C0C0C0",
                'figure.yaxis.major_tick_line_color': "#C0C0C0",
                'figure.yaxis.minor_tick_line_color': "#C0C0C0",
                'figure.xaxis.major_label_text_color': '#898989',
                'figure.yaxis.major_label_text_color': '#898989',
                'figure.outline_line_alpha': 1,
                'figure.outline_line_color': 'white',
                'figure.xaxis.axis_label_text_font': 'helvetica',
                'figure.yaxis.axis_label_text_font': 'helvetica',
                'figure.yaxis.major_label_text_font': 'helvetica',
                'figure.xaxis.major_label_text_font': 'helvetica',
                'figure.yaxis.axis_label_text_font_style': 'bold',
                'figure.xaxis.axis_label_text_font_style': 'bold',
                'figure.yaxis.axis_label_text_font_size': "11pt",
                'figure.xaxis.axis_label_text_font_size': "11pt",
                'figure.yaxis.major_label_text_font_size': "10pt",
                'figure.xaxis.major_label_text_font_size': "10pt",
                'figure.title.text_font': 'helvetica',
                'figure.title.text_color': '#333333',
                'figure.title.text_font_size': "18pt",
                'figure.xaxis.minor_tick_out': 1,
                'figure.yaxis.minor_tick_out': 1,
                'figure.xaxis.major_tick_line_width': 1,
                'figure.yaxis.major_tick_line_width': 1,
                'figure.xaxis.major_tick_out': 4,
                'figure.yaxis.major_tick_out': 4,
                'figure.xaxis.major_tick_in': 0,
                'figure.yaxis.major_tick_in': 0,
            },
            'categorical_xaxis': {
                # Used for grouped categorical axes
                'figure.xaxis.separator_line_alpha': 0,
                'figure.xaxis.subgroup_text_font': 'helvetica',
                'figure.xaxis.group_text_font': 'helvetica',
                'figure.xaxis.subgroup_text_font_size': "11pt",
                'figure.xaxis.group_text_font_size': "11pt",
                'figure.x_range.factor_padding': .25
            },
            'categorical_yaxis': {
                # Used for grouped categorical axes
                'figure.yaxis.separator_line_alpha': 0,
                'figure.yaxis.subgroup_text_font': 'helvetica',
                'figure.yaxis.group_text_font': 'helvetica',
                'figure.y_range.factor_padding': .25,
                'figure.yaxis.subgroup_text_font_size': "11pt",
                'figure.yaxis.group_text_font_size': "11pt",
            },
            'categorical_xyaxis': {
                # Used for grouped categorical axes
                'figure.yaxis.separator_line_alpha': 0,
                'figure.yaxis.subgroup_text_font': 'helvetica',
                'figure.yaxis.group_text_font': 'helvetica',
                'figure.yaxis.subgroup_text_font_size': "11pt",
                'figure.yaxis.group_text_font_size': "11pt",
                # Used for grouped categorical axes
                'figure.xaxis.separator_line_alpha': 0,
                'figure.xaxis.subgroup_text_font': 'helvetica',
                'figure.xaxis.group_text_font': 'helvetica',
                'figure.xaxis.subgroup_text_font_size': "11pt",
                'figure.xaxis.group_text_font_size': "11pt",
            },
            'subtitle': {
                'subtitle_align': 'left',
                'subtitle_text_color': '#666666',
                'subtitle_location': 'above',
                'subtitle_text_size': '12pt',
                'subtitle_text_size': '100%',
                'subtitle_text_font': 'helvetica'
            },
            'text_callout_and_plot': {
                'font': 'helvetica',
            },
            'interval_plot': {
                'space_between_bars': .25,
                'margin': .05,
                'bar_width': .9,
                'space_between_categories': 1.15,
                # Note each stem is drawn twice
                'interval_end_stem_size': .1 / 2,
                'interval_midpoint_stem_size': .03 / 2
            },
            'line_plot': {
                'line_cap': 'round',
                'line_join': 'round',
                'line_width': 4,
                'line_dash': 'solid'
            }
        }

        config_filename = options.get_option('config.style_settings')
        try:
            self._settings_from_yaml(
                config_filename, apply_chart_settings=False)
        except FileNotFoundError:
            pass

    def _set_width_and_height(self, layout='slide_100%'):
        """Set plot width and height based on the layout"""
        self.plot_width = 960
        self.plot_height = 540
        height_multiplier, width_multiplier = 1., 1.

        if layout == 'slide_75%':
            height_multiplier = 1. * .8
            width_multiplier = .75 * .8

        elif layout == 'slide_50%':
            height_multiplier = 1.
            width_multiplier = .5

        elif layout == 'slide_25%':
            height_multiplier = .5
            width_multiplier = .5

        self.plot_height = int(self.plot_height * height_multiplier)
        self.plot_width = int(self.plot_width * width_multiplier)

    def set_color_palette(self, palette_type, palette=None,
                          accent_values=None):
        """
        Args:
            palette_type:
                - 'categorical': Use when the color dimension
                    has no meaningful order.
                - 'sequential': Use when the color dimension
                    has a sequential order.
                - 'diverging'
                - 'accent': Use to assign color to specific
                    values in the color dimension.
            palette (color palette name, ColorPalette object, or list of colors)
                See chartify.color_palettes.show() for palette & color names.
                Default: 'Spotify Palette'
            accent_values (list or dict): List of values that should be
            accented or dictionary of 'value': 'color' pairs.
                Only applies to 'accent' palette type.
        """
        self.color_palette = BasePalette._get_palette_class(
            self._chart,
            palette_type=palette_type,
            palette=palette,
            accent_values=accent_values)

        return self._chart

    def _apply_bokeh_settings(self, attributes):
        for key, value in attributes.items():
            self._apply_bokeh_setting(key, value)

    def _apply_bokeh_setting(self, attribute, value, base_obj=None):
        """Recursively apply the settings value to the given settings attribute.
        Recursion is necessary because some bokeh objects may
        have multiple child objects.
        E.g. figures can have more than one x-axis.
        """
        # If not a bokeh attribute then we don't need to apply anything.
        if 'figure' not in attribute and base_obj is None:
            return

        split_attribute = attribute.split('.')
        if base_obj is None:
            base_obj = self._chart
        if len(split_attribute) == 1:
            setattr(base_obj, attribute, value)
        else:
            for i, attr in enumerate(split_attribute):
                if i < len(split_attribute) - 1:
                    base_obj = getattr(base_obj, attr)
                if isinstance(base_obj, (list, )):
                    for obj in base_obj:
                        self._apply_bokeh_setting(
                            '.'.join(split_attribute[i + 1:]),
                            value,
                            base_obj=obj)
                    break
            else:
                setattr(base_obj, attr, value)

    def _apply_settings(self, key):
        """Apply the specified bokeh settings"""
        setting_values = self.settings[key]
        self._apply_bokeh_settings(setting_values)

    def _get_settings(self, key):
        """Return the values of the given settings key"""
        setting_values = self.settings[key]
        return setting_values

    def _settings_to_yaml(self, filename):
        """Write the chart settings dict to a yaml file"""
        with open(filename, 'w') as outfile:
            yaml.dump(self.settings, outfile, default_flow_style=False)

    def _settings_from_yaml(self, filename, apply_chart_settings=True):
        """Load the chart settings dict from a yaml file"""
        yaml_settings = yaml.safe_load(open(filename))

        self.settings.update(yaml_settings)
        # Apply the settings that have been loaded.
        if apply_chart_settings:
            self._apply_settings('chart')